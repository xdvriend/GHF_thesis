%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{times}
\expandafter\ifx\csname T@LGR\endcsname\relax
\else
% LGR was declared as font encoding
  \substitutefont{LGR}{\rmdefault}{cmr}
  \substitutefont{LGR}{\sfdefault}{cmss}
  \substitutefont{LGR}{\ttdefault}{cmtt}
\fi
\expandafter\ifx\csname T@X2\endcsname\relax
  \expandafter\ifx\csname T@T2A\endcsname\relax
  \else
  % T2A was declared as font encoding
    \substitutefont{T2A}{\rmdefault}{cmr}
    \substitutefont{T2A}{\sfdefault}{cmss}
    \substitutefont{T2A}{\ttdefault}{cmtt}
  \fi
\else
% X2 was declared as font encoding
  \substitutefont{X2}{\rmdefault}{cmr}
  \substitutefont{X2}{\sfdefault}{cmss}
  \substitutefont{X2}{\ttdefault}{cmtt}
\fi


\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}
\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}



\title{GHF}
\date{Oct 22, 2019}
\release{0.1}
\author{Xeno De Vriendt}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}

\phantomsection\label{\detokenize{RHF:module-ghf.RHF}}\index{ghf.RHF (module)@\spxentry{ghf.RHF}\spxextra{module}}

\chapter{Restricted Hartree Fock, by means of SCF procedure}
\label{\detokenize{RHF:restricted-hartree-fock-by-means-of-scf-procedure}}\label{\detokenize{RHF::doc}}
This function calculates the RHF energy of a given molecule and the number of occupied orbitals.
The molecule has to be created in pySCF:
molecule = gto.M(atom = geometry, spin = diff. in alpha and beta electrons, basis = basis set)

number of occupied orbitals:
number of doubly occupied orbitals (1 for H\_2, 2 for H\_4,…)

The function prints the number of iterations and the converged SCF energy, while also returning the energy value
for eventual subsequent calculations
\index{RHF() (in module ghf.RHF)@\spxentry{RHF()}\spxextra{in module ghf.RHF}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{RHF:ghf.RHF.RHF}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ghf.RHF.}}\sphinxbfcode{\sphinxupquote{RHF}}}{\emph{molecule}, \emph{number\_occupied\_orbitals}}{}
Input is a molecule and the number of occupied orbitals.

Molecules are made in pySCF, eg.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{h\PYGZus{}2} \PYG{o}{=} \PYG{n}{gto}\PYG{o}{.}\PYG{n}{M}\PYG{p}{(}\PYG{n}{atom} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{h 0 0 0; h 0 0 1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{spin} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{basis} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cc\PYGZhy{}pvdz}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{RHF}\PYG{p}{(}\PYG{n}{h\PYGZus{}2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}
\end{sphinxVerbatim}

prints and returns RHF energy of h\_2

\end{fulllineitems}

\phantomsection\label{\detokenize{UHF:module-ghf.UHF}}\index{ghf.UHF (module)@\spxentry{ghf.UHF}\spxextra{module}}

\chapter{Unrestricted Hartree Fock, by means of SCF procedure}
\label{\detokenize{UHF:unrestricted-hartree-fock-by-means-of-scf-procedure}}\label{\detokenize{UHF::doc}}
This function calculates the UHF energy for a given molecule and the number of occupied alpha and beta orbitals. 
The molecule has to be created in pySCF:
molecule = gto.M(atom = geometry, spin = diff. in alpha and beta electrons, basis = basis set)

number of occupied orbitals:
first the number of occupied alpha orbitals
second the number of occupied beta orbitals

There are two extra options added into the function:
\begin{itemize}
\item {} 
extra\_e\_coeff: when true, the program will add two extra alpha electrons to the system and calculate when the new system’s energy converges. From the last density matrix in this calculation, new coefficients for the alpha and beta orbitals will be calculated and used as new guess density for the original system.

\item {} 
internal\_stability\_analysis: when true, an internal stability analysis will be performed. When the wave finction is deemed unstable, new coefficients will be calculated that are closer in value to the stable condition, which is done by varying the Hessian by means of a trial vector. These will then be used as a guess density for the energy calculation.

\end{itemize}

The function prints the number of iterations and the converged SCF energy, while also returning the energy value
for eventual subsequent calculations
\index{UHF() (in module ghf.UHF)@\spxentry{UHF()}\spxextra{in module ghf.UHF}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{UHF:ghf.UHF.UHF}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ghf.UHF.}}\sphinxbfcode{\sphinxupquote{UHF}}}{\emph{molecule}, \emph{occ\_a}, \emph{occ\_b}, \emph{extra\_e\_coeff=False}, \emph{internal\_stability\_analysis=False}}{}~
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{h3} \PYG{o}{=} \PYG{n}{gto}\PYG{o}{.}\PYG{n}{M}\PYG{p}{(}\PYG{n}{atom} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{h 0 0 0; h 0 0.86602540378 0.5; h 0 0 1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{spin} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{basis} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cc\PYGZhy{}pvdz}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{UHF}\PYG{p}{(}\PYG{n}{h3}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{h3} \PYG{o}{=} \PYG{n}{gto}\PYG{o}{.}\PYG{n}{M}\PYG{p}{(}\PYG{n}{atom} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{h 0 0 0; h 0 0.86602540378 0.5; h 0 0 1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{spin} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{basis} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cc\PYGZhy{}pvdz}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{UHF}\PYG{p}{(}\PYG{n}{h3}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{extra\PYGZus{}e\PYGZus{}coeff}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{h3} \PYG{o}{=} \PYG{n}{gto}\PYG{o}{.}\PYG{n}{M}\PYG{p}{(}\PYG{n}{atom} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{h 0 0 0; h 0 0.86602540378 0.5; h 0 0 1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{spin} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{basis} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cc\PYGZhy{}pvdz}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{UHF}\PYG{p}{(}\PYG{n}{h3}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{internal\PYGZus{}stability\PYGZus{}analysis}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{quote}

prints and returns UHF energy of h3
\end{quote}

\end{fulllineitems}

\phantomsection\label{\detokenize{real_GHF:module-ghf.real_GHF}}\index{ghf.real\_GHF (module)@\spxentry{ghf.real\_GHF}\spxextra{module}}

\chapter{Real generalised Hartree Fock, by means of SCF procedure}
\label{\detokenize{real_GHF:real-generalised-hartree-fock-by-means-of-scf-procedure}}\label{\detokenize{real_GHF::doc}}
This function calculates the real GHF energy for a given molecule and the number of electrons in the system.
The molecule has to be created in pySCF:
molecule = gto.M(atom = geometry, spin = diff. in alpha and beta electrons, basis = basis set)

The function can do this in two ways.
\begin{itemize}
\item {} 
Create the general density matrix and work with this as a whole

\item {} 
create the density matrix in spin-blocked notation

\end{itemize}
\index{real\_GHF() (in module ghf.real\_GHF)@\spxentry{real\_GHF()}\spxextra{in module ghf.real\_GHF}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{real_GHF:ghf.real_GHF.real_GHF}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ghf.real\_GHF.}}\sphinxbfcode{\sphinxupquote{real\_GHF}}}{\emph{molecule}, \emph{number\_of\_electrons}}{}
Input is a molecule and the number of electrons.

Molecules are made in pySCF, eg.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{h\PYGZus{}2} \PYG{o}{=} \PYG{n}{gto}\PYG{o}{.}\PYG{n}{M}\PYG{p}{(}\PYG{n}{atom} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{h 0 0 0; h 0 0 1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{spin} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{basis} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cc\PYGZhy{}pvdz}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{GHF}\PYG{p}{(}\PYG{n}{h\PYGZus{}2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}
\end{sphinxVerbatim}

prints and returns GHF energy of h\_2

\end{fulllineitems}

\phantomsection\label{\detokenize{SCF_functions:module-ghf.SCF_functions}}\index{ghf.SCF\_functions (module)@\spxentry{ghf.SCF\_functions}\spxextra{module}}

\chapter{Useful functions for SCF procedure}
\label{\detokenize{SCF_functions:useful-functions-for-scf-procedure}}\label{\detokenize{SCF_functions::doc}}
A number of functions used throughout the UHF and RHF calculations are summarised here.
\index{density\_matrix() (in module ghf.SCF\_functions)@\spxentry{density\_matrix()}\spxextra{in module ghf.SCF\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{SCF_functions:ghf.SCF_functions.density_matrix}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ghf.SCF\_functions.}}\sphinxbfcode{\sphinxupquote{density\_matrix}}}{\emph{f\_matrix}, \emph{occ}, \emph{trans}}{}~\begin{itemize}
\item {} 
density() creates a density matrix from a fock matrix and the number of occupied orbitals.

\item {} 
Input is a fock matrix, the number of occupied orbitals, which can be separate for alpha and beta in case of UHF. And

\end{itemize}

a transformation matrix X.

\end{fulllineitems}

\index{get\_integrals() (in module ghf.SCF\_functions)@\spxentry{get\_integrals()}\spxextra{in module ghf.SCF\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{SCF_functions:ghf.SCF_functions.get_integrals}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ghf.SCF\_functions.}}\sphinxbfcode{\sphinxupquote{get\_integrals}}}{\emph{molecule}}{}
A function to calculate your integrals \& nuclear repulsion with pyscf.

\end{fulllineitems}

\index{spin() (in module ghf.SCF\_functions)@\spxentry{spin()}\spxextra{in module ghf.SCF\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{SCF_functions:ghf.SCF_functions.spin}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ghf.SCF\_functions.}}\sphinxbfcode{\sphinxupquote{spin}}}{\emph{occ\_a}, \emph{occ\_b}, \emph{coeff\_a}, \emph{coeff\_b}, \emph{overlap}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{occ\_a}} \textendash{} number of occupied alpha orbitals

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{occ\_b}} \textendash{} number of occupied beta orbitals

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{coeff\_a}} \textendash{} MO coefficients of alpha orbitals

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{coeff\_b}} \textendash{} MO coefficients of beta orbitals

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{overlap}} \textendash{} overlap matrix of the molecule

\end{itemize}

\item[{Returns}] \leavevmode
S\textasciicircum{}2, S\_z and spin multiplicity

\end{description}\end{quote}

\end{fulllineitems}

\index{trans\_matrix() (in module ghf.SCF\_functions)@\spxentry{trans\_matrix()}\spxextra{in module ghf.SCF\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{SCF_functions:ghf.SCF_functions.trans_matrix}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ghf.SCF\_functions.}}\sphinxbfcode{\sphinxupquote{trans\_matrix}}}{\emph{overlap}}{}~\begin{itemize}
\item {} 
Define a transformation matrix X, used to orthogonalize different matrices throughout the calculation.

\item {} 
Input should be an overlap matrix.

\end{itemize}

\end{fulllineitems}

\index{uhf\_fock\_matrix() (in module ghf.SCF\_functions)@\spxentry{uhf\_fock\_matrix()}\spxextra{in module ghf.SCF\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{SCF_functions:ghf.SCF_functions.uhf_fock_matrix}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ghf.SCF\_functions.}}\sphinxbfcode{\sphinxupquote{uhf\_fock\_matrix}}}{\emph{density\_matrix\_1}, \emph{density\_matrix\_2}, \emph{one\_electron}, \emph{two\_electron}}{}~\begin{itemize}
\item {} 
calculate a fock matrix from a given alpha and beta density matrix

\item {} 
fock alpha if 1 = alpha and 2 = beta and vice versa

\item {} 
input is the density matrix for alpha and beta, a one electron matrix and a two electron tensor.

\end{itemize}

\end{fulllineitems}

\index{uhf\_scf\_energy() (in module ghf.SCF\_functions)@\spxentry{uhf\_scf\_energy()}\spxextra{in module ghf.SCF\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{SCF_functions:ghf.SCF_functions.uhf_scf_energy}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ghf.SCF\_functions.}}\sphinxbfcode{\sphinxupquote{uhf\_scf\_energy}}}{\emph{density\_matrix\_a}, \emph{density\_matrix\_b}, \emph{fock\_a}, \emph{fock\_b}, \emph{one\_electron}}{}~\begin{itemize}
\item {} 
calculate the scf energy value from a given density matrix and a given fock matrix for both alpha and beta, so 4 matrices in total

\item {} 
then calculate the initial electronic energy and put it into an array

\item {} 
input is the density matrices for alpha and beta, the fock matrices for alpha and beta and lastly a one electron matrix

\end{itemize}

\end{fulllineitems}

\phantomsection\label{\detokenize{tests:module-ghf.tests.test_auth}}\index{ghf.tests.test\_auth (module)@\spxentry{ghf.tests.test\_auth}\spxextra{module}}

\chapter{Testing the RHF and UHF methods}
\label{\detokenize{tests:testing-the-rhf-and-uhf-methods}}\label{\detokenize{tests::doc}}
Simple tests to check whether or not the functions return the correct value.
\index{test\_RHF() (in module ghf.tests.test\_auth)@\spxentry{test\_RHF()}\spxextra{in module ghf.tests.test\_auth}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tests:ghf.tests.test_auth.test_RHF}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ghf.tests.test\_auth.}}\sphinxbfcode{\sphinxupquote{test\_RHF}}}{}{}
test\_RHF will test whether or not the RHF method returns the wanted result. The accuracy is 10\textasciicircum{}16.

\end{fulllineitems}

\index{test\_UHF() (in module ghf.tests.test\_auth)@\spxentry{test\_UHF()}\spxextra{in module ghf.tests.test\_auth}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tests:ghf.tests.test_auth.test_UHF}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ghf.tests.test\_auth.}}\sphinxbfcode{\sphinxupquote{test\_UHF}}}{}{}
test\_UHF will test the regular UHF method, by checking whether or not it returns the expected result. The accuracy is 10\textasciicircum{}-6.

\end{fulllineitems}

\index{test\_extra\_e() (in module ghf.tests.test\_auth)@\spxentry{test\_extra\_e()}\spxextra{in module ghf.tests.test\_auth}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tests:ghf.tests.test_auth.test_extra_e}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ghf.tests.test\_auth.}}\sphinxbfcode{\sphinxupquote{test\_extra\_e}}}{}{}
test\_extra\_e will test the UHF method, with the added option of first adding 2 electrons to the system and using those coefficients
for the actual system, by checking whether or not it returns the expected result. The accuracy is 10\textasciicircum{}-6.

\end{fulllineitems}

\index{test\_stability() (in module ghf.tests.test\_auth)@\spxentry{test\_stability()}\spxextra{in module ghf.tests.test\_auth}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tests:ghf.tests.test_auth.test_stability}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ghf.tests.test\_auth.}}\sphinxbfcode{\sphinxupquote{test\_stability}}}{}{}
test\_stability will test the UHF method, with stability analysis, by checking whether or not it returns the expected result. The accuracy is 10\textasciicircum{}-6.

\end{fulllineitems}



\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\let\bigletter\sphinxstyleindexlettergroup
\bigletter{g}
\item\relax\sphinxstyleindexentry{ghf.real\_GHF}\sphinxstyleindexpageref{real_GHF:\detokenize{module-ghf.real_GHF}}
\item\relax\sphinxstyleindexentry{ghf.RHF}\sphinxstyleindexpageref{RHF:\detokenize{module-ghf.RHF}}
\item\relax\sphinxstyleindexentry{ghf.SCF\_functions}\sphinxstyleindexpageref{SCF_functions:\detokenize{module-ghf.SCF_functions}}
\item\relax\sphinxstyleindexentry{ghf.tests.test\_auth}\sphinxstyleindexpageref{tests:\detokenize{module-ghf.tests.test_auth}}
\item\relax\sphinxstyleindexentry{ghf.UHF}\sphinxstyleindexpageref{UHF:\detokenize{module-ghf.UHF}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}