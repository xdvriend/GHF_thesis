%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{times}
\expandafter\ifx\csname T@LGR\endcsname\relax
\else
% LGR was declared as font encoding
  \substitutefont{LGR}{\rmdefault}{cmr}
  \substitutefont{LGR}{\sfdefault}{cmss}
  \substitutefont{LGR}{\ttdefault}{cmtt}
\fi
\expandafter\ifx\csname T@X2\endcsname\relax
  \expandafter\ifx\csname T@T2A\endcsname\relax
  \else
  % T2A was declared as font encoding
    \substitutefont{T2A}{\rmdefault}{cmr}
    \substitutefont{T2A}{\sfdefault}{cmss}
    \substitutefont{T2A}{\ttdefault}{cmtt}
  \fi
\else
% X2 was declared as font encoding
  \substitutefont{X2}{\rmdefault}{cmr}
  \substitutefont{X2}{\sfdefault}{cmss}
  \substitutefont{X2}{\ttdefault}{cmtt}
\fi


\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}
\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}



\title{GHF}
\date{Apr 23, 2020}
\release{0.1}
\author{Xeno De Vriendt}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}

\phantomsection\label{\detokenize{RHF:module-hf.HartreeFock.RHF}}\index{hf.HartreeFock.RHF (module)@\spxentry{hf.HartreeFock.RHF}\spxextra{module}}

\chapter{Restricted Hartree Fock, by means of SCF procedure}
\label{\detokenize{RHF:restricted-hartree-fock-by-means-of-scf-procedure}}\label{\detokenize{RHF::doc}}
This class is used to calculate the RHF energy of a given molecule and the number of electrons.
The molecule has to be created in pySCF:
molecule = gto.M(atom = geometry, spin = diff. in alpha and beta electrons, basis = basis set)
\index{MF (class in hf.HartreeFock.RHF)@\spxentry{MF}\spxextra{class in hf.HartreeFock.RHF}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{RHF:hf.HartreeFock.RHF.MF}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{hf.HartreeFock.RHF.}}\sphinxbfcode{\sphinxupquote{MF}}}{\emph{molecule}, \emph{number\_of\_electrons}, \emph{int\_method='pyscf'}}{}
Input is a molecule and the number of electrons.

Molecules are made in pySCF and calculations are performed as follows, eg.:
The following snippet prints and returns RHF energy of h\_2
and the number of iterations needed to get this value.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{hf}\PYG{n+nn}{.}\PYG{n+nn}{HartreeFock} \PYG{k}{import} \PYG{o}{*}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{h\PYGZus{}2} \PYG{o}{=} \PYG{n}{gto}\PYG{o}{.}\PYG{n}{M}\PYG{p}{(}\PYG{n}{atom} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{h 0 0 0; h 0 0 1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{spin} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{basis} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{sto\PYGZhy{}3g}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x} \PYG{o}{=} \PYG{n}{RHF}\PYG{o}{.}\PYG{n}{MF}\PYG{p}{(}\PYG{n}{h\PYGZus{}2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x}\PYG{o}{.}\PYG{n}{get\PYGZus{}scf\PYGZus{}solution}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{Number of iterations: 6}
\PYG{g+go}{Converged SCF energy in Hartree: \PYGZhy{}1.0661086493179357 (RHF)}
\end{sphinxVerbatim}
\index{diis() (hf.HartreeFock.RHF.MF method)@\spxentry{diis()}\spxextra{hf.HartreeFock.RHF.MF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{RHF:hf.HartreeFock.RHF.MF.diis}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{diis}}}{\emph{convergence=1e-12}, \emph{complex\_method=False}}{}
When needed, DIIS can be used to speed up the RHF calculations by reducing the needed iterations.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{convergence}} \textendash{} Set the convergence criterion. If none is given, 1e-12 is used.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{complex\_method}} \textendash{} Specify whether or not you want to work in the complex space. Default is real.

\end{itemize}

\item[{Returns}] \leavevmode
scf energy, number of iterations, mo coefficients, last density matrix, last fock matrix

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_last\_dens() (hf.HartreeFock.RHF.MF method)@\spxentry{get\_last\_dens()}\spxextra{hf.HartreeFock.RHF.MF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{RHF:hf.HartreeFock.RHF.MF.get_last_dens}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_last\_dens}}}{}{}
Returns the last density matrix of the converged solution.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The last density matrix.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_last\_fock() (hf.HartreeFock.RHF.MF method)@\spxentry{get\_last\_fock()}\spxextra{hf.HartreeFock.RHF.MF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{RHF:hf.HartreeFock.RHF.MF.get_last_fock}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_last\_fock}}}{}{}
Returns the last fock matrix of the converged solution.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The last Fock matrix.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_mo\_coeff() (hf.HartreeFock.RHF.MF method)@\spxentry{get\_mo\_coeff()}\spxextra{hf.HartreeFock.RHF.MF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{RHF:hf.HartreeFock.RHF.MF.get_mo_coeff}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_mo\_coeff}}}{}{}
Returns mo coefficients of the converged solution.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The mo coefficients

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_one\_e() (hf.HartreeFock.RHF.MF method)@\spxentry{get\_one\_e()}\spxextra{hf.HartreeFock.RHF.MF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{RHF:hf.HartreeFock.RHF.MF.get_one_e}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_one\_e}}}{}{}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The one electron integral matrix: T + V

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_ovlp() (hf.HartreeFock.RHF.MF method)@\spxentry{get\_ovlp()}\spxextra{hf.HartreeFock.RHF.MF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{RHF:hf.HartreeFock.RHF.MF.get_ovlp}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_ovlp}}}{}{}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The overlap matrix

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_scf\_solution() (hf.HartreeFock.RHF.MF method)@\spxentry{get\_scf\_solution()}\spxextra{hf.HartreeFock.RHF.MF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{RHF:hf.HartreeFock.RHF.MF.get_scf_solution}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_scf\_solution}}}{\emph{convergence=1e-12}, \emph{complex\_method=False}}{}
Prints the number of iterations and the converged scf energy.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{convergence}} \textendash{} Set the convergence criterion. If none is given, 1e-12 is used.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{complex\_method}} \textendash{} Specify whether or not you want to work in the complex space. Default is real.

\end{itemize}

\item[{Returns}] \leavevmode
the converged energy

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_scf\_solution\_diis() (hf.HartreeFock.RHF.MF method)@\spxentry{get\_scf\_solution\_diis()}\spxextra{hf.HartreeFock.RHF.MF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{RHF:hf.HartreeFock.RHF.MF.get_scf_solution_diis}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_scf\_solution\_diis}}}{\emph{convergence=1e-12}, \emph{complex\_method=False}}{}
Prints the number of iterations and the converged DIIS energy. The number of iterations will be lower than with
a normal scf, but the energy value will be the same. Example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{hf}\PYG{n+nn}{.}\PYG{n+nn}{HartreeFock} \PYG{k}{import} \PYG{o}{*}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{h2} \PYG{o}{=} \PYG{n}{gto}\PYG{o}{.}\PYG{n}{M}\PYG{p}{(}\PYG{n}{atom} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{h 0 0 0; h 1 0 0}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{basis} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cc\PYGZhy{}pvdz}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x} \PYG{o}{=} \PYG{n}{RHF}\PYG{o}{.}\PYG{n}{MF}\PYG{p}{(}\PYG{n}{h2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x}\PYG{o}{.}\PYG{n}{get\PYGZus{}scf\PYGZus{}solution\PYGZus{}diis}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{Number of iterations: 5}
\PYG{g+go}{Converged SCF energy in Hartree: \PYGZhy{}1.100153764878446 (RHF)}
\end{sphinxVerbatim}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{convergence}} \textendash{} Set the convergence criterion. If none is given, 1e-12 is used.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{complex\_method}} \textendash{} Specify whether or not you want to work in the complex space. Default is real.

\end{itemize}

\item[{Returns}] \leavevmode
The converged scf energy, using DIIS.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_two\_e() (hf.HartreeFock.RHF.MF method)@\spxentry{get\_two\_e()}\spxextra{hf.HartreeFock.RHF.MF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{RHF:hf.HartreeFock.RHF.MF.get_two_e}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_two\_e}}}{}{}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The electron repulsion interaction tensor

\end{description}\end{quote}

\end{fulllineitems}

\index{nuc\_rep() (hf.HartreeFock.RHF.MF method)@\spxentry{nuc\_rep()}\spxextra{hf.HartreeFock.RHF.MF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{RHF:hf.HartreeFock.RHF.MF.nuc_rep}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{nuc\_rep}}}{}{}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The nuclear repulsion value

\end{description}\end{quote}

\end{fulllineitems}

\index{scf() (hf.HartreeFock.RHF.MF method)@\spxentry{scf()}\spxextra{hf.HartreeFock.RHF.MF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{RHF:hf.HartreeFock.RHF.MF.scf}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{scf}}}{\emph{convergence=1e-12}, \emph{complex\_method=False}}{}
Performs a self consistent field calculation to find the lowest RHF energy.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{convergence}} \textendash{} Convergence criterion. If none is specified, 1e-12 is used.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{complex\_method}} \textendash{} Specify whether or not you want to work in the complex space. Default is real.

\end{itemize}

\item[{Returns}] \leavevmode
number of iterations, scf energy, mo coefficients, last density matrix, last fock matrix

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\phantomsection\label{\detokenize{UHF:module-hf.HartreeFock.UHF}}\index{hf.HartreeFock.UHF (module)@\spxentry{hf.HartreeFock.UHF}\spxextra{module}}

\chapter{Unrestricted Hartree Fock, by means of SCF procedure}
\label{\detokenize{UHF:unrestricted-hartree-fock-by-means-of-scf-procedure}}\label{\detokenize{UHF::doc}}
This class is used to calculate the UHF energy for a given molecule and the number of electrons of that molecule.
Several options are available to make sure you get the lowest energy from your calculation, as well as some useful
functions to get intermediate values such as MO coefficients, density and fock matrices.
\index{MF (class in hf.HartreeFock.UHF)@\spxentry{MF}\spxextra{class in hf.HartreeFock.UHF}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{UHF:hf.HartreeFock.UHF.MF}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{hf.HartreeFock.UHF.}}\sphinxbfcode{\sphinxupquote{MF}}}{\emph{molecule}, \emph{number\_of\_electrons}, \emph{int\_method='pyscf'}}{}
Input is a molecule and the number of electrons.

Molecules are made in pySCF and calculations are performed as follows, eg.:
The following snippet prints and returns UHF energy of h\_3
and the number of iterations needed to get this value.

For a normal scf calculation your input looks like the following example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{hf}\PYG{n+nn}{.}\PYG{n+nn}{HartreeFock} \PYG{k}{import} \PYG{o}{*}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{h3} \PYG{o}{=} \PYG{n}{gto}\PYG{o}{.}\PYG{n}{M}\PYG{p}{(}\PYG{n}{atom} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{h 0 0 0; h 0 0.86602540378 0.5; h 0 0 1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{spin} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{basis} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cc\PYGZhy{}pvdz}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x} \PYG{o}{=} \PYG{n}{UHF}\PYG{o}{.}\PYG{n}{MF}\PYG{p}{(}\PYG{n}{h3}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x}\PYG{o}{.}\PYG{n}{get\PYGZus{}scf\PYGZus{}solution}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{Number of iterations: 47}
\PYG{g+go}{Converged SCF energy in Hartree: \PYGZhy{}1.506274320261134 (UHF)}
\PYG{g+go}{\PYGZlt{}S\PYGZca{}2\PYGZgt{} = 0.7735672504295973, \PYGZlt{}S\PYGZus{}z\PYGZgt{} = 0.5, Multiplicity = 2.023430009098014}
\end{sphinxVerbatim}
\index{diis() (hf.HartreeFock.UHF.MF method)@\spxentry{diis()}\spxextra{hf.HartreeFock.UHF.MF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{UHF:hf.HartreeFock.UHF.MF.diis}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{diis}}}{\emph{initial\_guess=None}, \emph{convergence=1e-12}, \emph{complex\_method=False}}{}
When needed, DIIS can be used to speed up the UHF calculations by reducing the needed iterations.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{initial\_guess}} \textendash{} Initial guess for the scf procedure. None specified: core Hamiltonian.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{convergence}} \textendash{} Set the convergence criterion. If none is given, 1e-12 is used.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{complex\_method}} \textendash{} Specify whether or not you want to work in the complex space. Default is real.

\end{itemize}

\item[{Returns}] \leavevmode
scf energy, number of iterations, mo coefficients, last density matrix, last fock matrix

\end{description}\end{quote}

\end{fulllineitems}

\index{extra\_electron\_guess() (hf.HartreeFock.UHF.MF method)@\spxentry{extra\_electron\_guess()}\spxextra{hf.HartreeFock.UHF.MF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{UHF:hf.HartreeFock.UHF.MF.extra_electron_guess}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{extra\_electron\_guess}}}{}{}
This method adds two electrons to the system in order to get coefficients that can be used as a better guess
for the scf procedure. This essentially forces the system into it’s \textless{}S\_z\textgreater{} = 0 state.

!!!IMPORTANT!!! Only supported with pyscf.

To perform a calculation with this method, you will have to work as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{hf}\PYG{n+nn}{.}\PYG{n+nn}{HartreeFock} \PYG{k}{import} \PYG{o}{*}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{h4} \PYG{o}{=} \PYG{n}{gto}\PYG{o}{.}\PYG{n}{M}\PYG{p}{(}\PYG{n}{atom} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{h 0 0 0; h 1 0 0; h 0 1 0; h 1 1 0}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{,} \PYG{n}{spin} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{basis} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cc\PYGZhy{}pvdz}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x} \PYG{o}{=} \PYG{n}{UHF}\PYG{o}{.}\PYG{n}{MF}\PYG{p}{(}\PYG{n}{h4}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{guess} \PYG{o}{=} \PYG{n}{x}\PYG{o}{.}\PYG{n}{extra\PYGZus{}electron\PYGZus{}guess}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x}\PYG{o}{.}\PYG{n}{get\PYGZus{}scf\PYGZus{}solution}\PYG{p}{(}\PYG{n}{guess}\PYG{p}{)}
\PYG{g+go}{Number of iterations: 60}
\PYG{g+go}{Converged SCF energy in Hartree: \PYGZhy{}2.0210882477030547 (UHF)}
\PYG{g+go}{\PYGZlt{}S\PYGZca{}2\PYGZgt{} = 1.0565277001056579, \PYGZlt{}S\PYGZus{}z\PYGZgt{} = 0.0, Multiplicity = 2.2860688529487976}
\end{sphinxVerbatim}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
A new guess matrix to use for the scf procedure.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_hessian() (hf.HartreeFock.UHF.MF method)@\spxentry{get\_hessian()}\spxextra{hf.HartreeFock.UHF.MF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{UHF:hf.HartreeFock.UHF.MF.get_hessian}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_hessian}}}{}{}
Get the Hessian matrix after performing a stability analysis.
:return: The hessian matrix

\end{fulllineitems}

\index{get\_last\_dens() (hf.HartreeFock.UHF.MF method)@\spxentry{get\_last\_dens()}\spxextra{hf.HartreeFock.UHF.MF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{UHF:hf.HartreeFock.UHF.MF.get_last_dens}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_last\_dens}}}{}{}
Gets the last density matrix of the converged solution.
Alpha density in the first matrix, beta density in the second.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The last density matrix.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_last\_fock() (hf.HartreeFock.UHF.MF method)@\spxentry{get\_last\_fock()}\spxextra{hf.HartreeFock.UHF.MF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{UHF:hf.HartreeFock.UHF.MF.get_last_fock}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_last\_fock}}}{}{}
Gets the last fock matrix of the converged solution.
Alpha Fock matrix first, beta Fock matrix second.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The last Fock matrix.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_mo\_coeff() (hf.HartreeFock.UHF.MF method)@\spxentry{get\_mo\_coeff()}\spxextra{hf.HartreeFock.UHF.MF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{UHF:hf.HartreeFock.UHF.MF.get_mo_coeff}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_mo\_coeff}}}{}{}
Gets the mo coefficients of the converged solution.
Alpha coefficients in the first matrix, beta coefficients in the second.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The mo coefficients

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_one\_e() (hf.HartreeFock.UHF.MF method)@\spxentry{get\_one\_e()}\spxextra{hf.HartreeFock.UHF.MF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{UHF:hf.HartreeFock.UHF.MF.get_one_e}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_one\_e}}}{}{}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The one electron integral matrix: T + V

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_ovlp() (hf.HartreeFock.UHF.MF method)@\spxentry{get\_ovlp()}\spxextra{hf.HartreeFock.UHF.MF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{UHF:hf.HartreeFock.UHF.MF.get_ovlp}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_ovlp}}}{}{}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The overlap matrix

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_scf\_solution() (hf.HartreeFock.UHF.MF method)@\spxentry{get\_scf\_solution()}\spxextra{hf.HartreeFock.UHF.MF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{UHF:hf.HartreeFock.UHF.MF.get_scf_solution}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_scf\_solution}}}{\emph{guess=None}, \emph{convergence=1e-12}, \emph{complex\_method=False}}{}
Prints the number of iterations and the converged scf energy.
Also prints the expectation value of S\_z, S\textasciicircum{}2 and the multiplicity.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{guess}} \textendash{} The initial guess for the scf procedure. If none is given: core Hamiltonian.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{convergence}} \textendash{} Set the convergence criterion. If none is given, 1e-12 is used.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{complex\_method}} \textendash{} Specify whether or not you want to work in the complex space. Default is real.

\end{itemize}

\item[{Returns}] \leavevmode
The converged scf energy.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_scf\_solution\_diis() (hf.HartreeFock.UHF.MF method)@\spxentry{get\_scf\_solution\_diis()}\spxextra{hf.HartreeFock.UHF.MF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{UHF:hf.HartreeFock.UHF.MF.get_scf_solution_diis}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_scf\_solution\_diis}}}{\emph{guess=None}, \emph{convergence=1e-12}, \emph{complex\_method=False}}{}
Prints the number of iterations and the converged diis energy.
Also prints the expectation value of S\_z, S\textasciicircum{}2 and the multiplicity.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{guess}} \textendash{} The initial guess. If none is specified, core Hamiltonian.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{convergence}} \textendash{} Set the convergence criterion. If none is given, 1e-12 is used.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{complex\_method}} \textendash{} Specify whether or not you want to work in the complex space. Default is real.

\end{itemize}

\item[{Returns}] \leavevmode
The converged diis energy.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_two\_e() (hf.HartreeFock.UHF.MF method)@\spxentry{get\_two\_e()}\spxextra{hf.HartreeFock.UHF.MF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{UHF:hf.HartreeFock.UHF.MF.get_two_e}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_two\_e}}}{}{}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The electron repulsion interaction tensor

\end{description}\end{quote}

\end{fulllineitems}

\index{nuc\_rep() (hf.HartreeFock.UHF.MF method)@\spxentry{nuc\_rep()}\spxextra{hf.HartreeFock.UHF.MF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{UHF:hf.HartreeFock.UHF.MF.nuc_rep}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{nuc\_rep}}}{}{}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The nuclear repulsion value

\end{description}\end{quote}

\end{fulllineitems}

\index{scf() (hf.HartreeFock.UHF.MF method)@\spxentry{scf()}\spxextra{hf.HartreeFock.UHF.MF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{UHF:hf.HartreeFock.UHF.MF.scf}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{scf}}}{\emph{initial\_guess=None}, \emph{convergence=1e-12}, \emph{complex\_method=False}}{}
Performs a self consistent field calculation to find the lowest UHF energy.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{initial\_guess}} \textendash{} A tuple of an alpha and beta guess matrix. If none, the core hamiltonian will be used.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{convergence}} \textendash{} Set the convergence criterion. If none is given, 1e-12 is used.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{complex\_method}} \textendash{} Specify whether or not you want to work in the complex space. Default is real.

\end{itemize}

\item[{Returns}] \leavevmode
The scf energy, number of iterations, the mo coefficients, the last density and the last fock matrices

\end{description}\end{quote}

\end{fulllineitems}

\index{stability() (hf.HartreeFock.UHF.MF method)@\spxentry{stability()}\spxextra{hf.HartreeFock.UHF.MF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{UHF:hf.HartreeFock.UHF.MF.stability}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{stability}}}{}{}
Performing a stability analysis checks whether or not the wave function is stable, by checking the lowest eigen-
value of the Hessian matrix. If there’s an instability, the MO’s will be rotated in the direction
of the lowest eigenvalue. These new MO’s can then be used to start a new scf procedure.

To perform a stability analysis, use the following syntax:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{hf}\PYG{n+nn}{.}\PYG{n+nn}{HartreeFock} \PYG{k}{import} \PYG{o}{*}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{h4} \PYG{o}{=} \PYG{n}{gto}\PYG{o}{.}\PYG{n}{M}\PYG{p}{(}\PYG{n}{atom} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{h 0 0 0; h 1 0 0; h 0 1 0; h 1 1 0}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{,} \PYG{n}{spin} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{basis} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cc\PYGZhy{}pvdz}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x} \PYG{o}{=} \PYG{n}{UHF}\PYG{o}{.}\PYG{n}{MF}\PYG{p}{(}\PYG{n}{h4}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{guess} \PYG{o}{=} \PYG{n}{x}\PYG{o}{.}\PYG{n}{stability}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x}\PYG{o}{.}\PYG{n}{get\PYGZus{}scf\PYGZus{}solution}\PYG{p}{(}\PYG{n}{guess}\PYG{p}{)}
\PYG{g+go}{There is an internal instability in the UHF wave function.}
\PYG{g+go}{Number of iterations: 66}
\PYG{g+go}{Converged SCF energy in Hartree: \PYGZhy{}2.0210882477030716 (UHF)}
\PYG{g+go}{\PYGZlt{}S\PYGZca{}2\PYGZgt{} = 1.056527700105677, \PYGZlt{}S\PYGZus{}z\PYGZgt{} = 0.0, Multiplicity = 2.2860688529488145}
\end{sphinxVerbatim}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
New and improved MO’s.

\end{description}\end{quote}

\end{fulllineitems}

\index{stability\_analysis() (hf.HartreeFock.UHF.MF method)@\spxentry{stability\_analysis()}\spxextra{hf.HartreeFock.UHF.MF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{UHF:hf.HartreeFock.UHF.MF.stability_analysis}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{stability\_analysis}}}{\emph{method}, \emph{step\_size=1e-05}}{}
Internal stability analysis to verify whether the wave function is stable within the space of the used method.
:param method: Indicate whether you want to check the internal or external stability of the wave function. Can
be internal or external.
:param step\_size: Step size for orbital rotation. standard is 1e-5.
:return: In case of internal stability analysis, it returns a new set of coefficients.

\end{fulllineitems}


\end{fulllineitems}

\phantomsection\label{\detokenize{cUHF_s:module-hf.HartreeFock.cUHF_s}}\index{hf.HartreeFock.cUHF\_s (module)@\spxentry{hf.HartreeFock.cUHF\_s}\spxextra{module}}

\chapter{Constrained unrestricted Hartree Fock by Scuseria}
\label{\detokenize{cUHF_s:constrained-unrestricted-hartree-fock-by-scuseria}}\label{\detokenize{cUHF_s::doc}}
This class is used to calculate the ROHF energy for a given molecule and the number of electrons of that molecule,
using a constrained version of unrestricted Hartree Fock, according to Scuseria..
Several options are available to make sure you get the lowest energy from your calculation, as well as some useful
functions to get intermediate values such as MO coefficients, density and fock matrices.
\index{MF (class in hf.HartreeFock.cUHF\_s)@\spxentry{MF}\spxextra{class in hf.HartreeFock.cUHF\_s}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cUHF_s:hf.HartreeFock.cUHF_s.MF}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{hf.HartreeFock.cUHF\_s.}}\sphinxbfcode{\sphinxupquote{MF}}}{\emph{molecule}, \emph{number\_of\_electrons}, \emph{int\_method='pyscf'}}{}
Input is a molecule and the number of electrons.

Molecules are made in pySCF/psi4 and calculations are performed as follows, eg.:
The following snippet prints and returns UHF energy of h\_3
and the number of iterations needed to get this value.

For a normal scf calculation your input looks like the following example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{hf}\PYG{n+nn}{.}\PYG{n+nn}{HartreeFock} \PYG{k}{import} \PYG{o}{*}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{h3} \PYG{o}{=} \PYG{n}{gto}\PYG{o}{.}\PYG{n}{M}\PYG{p}{(}\PYG{n}{atom} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{h 0 0 0; h 0 0.86602540378 0.5; h 0 0 1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{spin} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{basis} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cc\PYGZhy{}pvdz}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x} \PYG{o}{=} \PYG{n}{cUHF\PYGZus{}s}\PYG{o}{.}\PYG{n}{MF}\PYG{p}{(}\PYG{n}{h3}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x}\PYG{o}{.}\PYG{n}{get\PYGZus{}scf\PYGZus{}solution}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}
\index{get\_dens() (hf.HartreeFock.cUHF\_s.MF method)@\spxentry{get\_dens()}\spxextra{hf.HartreeFock.cUHF\_s.MF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cUHF_s:hf.HartreeFock.cUHF_s.MF.get_dens}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_dens}}}{\emph{i=-1}}{}
Gets the last density matrix of the converged solution.
Alpha density in the first matrix, beta density in the second.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The last density matrix.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_fock() (hf.HartreeFock.cUHF\_s.MF method)@\spxentry{get\_fock()}\spxextra{hf.HartreeFock.cUHF\_s.MF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cUHF_s:hf.HartreeFock.cUHF_s.MF.get_fock}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_fock}}}{\emph{i=-1}}{}
Gets the last fock matrix of the converged solution.
Alpha Fock matrix first, beta Fock matrix second.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The last Fock matrix.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_mo\_coeff() (hf.HartreeFock.cUHF\_s.MF method)@\spxentry{get\_mo\_coeff()}\spxextra{hf.HartreeFock.cUHF\_s.MF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cUHF_s:hf.HartreeFock.cUHF_s.MF.get_mo_coeff}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_mo\_coeff}}}{\emph{i=-1}}{}
Gets the mo coefficients of the converged solution.
Alpha coefficients in the first matrix, beta coefficients in the second.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The mo coefficients

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_one\_e() (hf.HartreeFock.cUHF\_s.MF method)@\spxentry{get\_one\_e()}\spxextra{hf.HartreeFock.cUHF\_s.MF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cUHF_s:hf.HartreeFock.cUHF_s.MF.get_one_e}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_one\_e}}}{}{}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The one electron integral matrix: T + V

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_ovlp() (hf.HartreeFock.cUHF\_s.MF method)@\spxentry{get\_ovlp()}\spxextra{hf.HartreeFock.cUHF\_s.MF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cUHF_s:hf.HartreeFock.cUHF_s.MF.get_ovlp}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_ovlp}}}{}{}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The overlap matrix

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_scf\_solution() (hf.HartreeFock.cUHF\_s.MF method)@\spxentry{get\_scf\_solution()}\spxextra{hf.HartreeFock.cUHF\_s.MF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cUHF_s:hf.HartreeFock.cUHF_s.MF.get_scf_solution}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_scf\_solution}}}{\emph{guess=None}, \emph{convergence=1e-12}, \emph{diis=True}}{}
Prints the number of iterations and the converged scf energy.
Also prints the expectation value of S\_z, S\textasciicircum{}2 and the multiplicity.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{guess}} \textendash{} Initial scf guess

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{convergence}} \textendash{} Set the convergence criterion. If none is given, 1e-12 is used.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{diis}} \textendash{} Accelerates the convergence, default is true.

\end{itemize}

\item[{Returns}] \leavevmode
The converged scf energy.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_two\_e() (hf.HartreeFock.cUHF\_s.MF method)@\spxentry{get\_two\_e()}\spxextra{hf.HartreeFock.cUHF\_s.MF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cUHF_s:hf.HartreeFock.cUHF_s.MF.get_two_e}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_two\_e}}}{}{}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The electron repulsion interaction tensor

\end{description}\end{quote}

\end{fulllineitems}

\index{nuc\_rep() (hf.HartreeFock.cUHF\_s.MF method)@\spxentry{nuc\_rep()}\spxextra{hf.HartreeFock.cUHF\_s.MF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cUHF_s:hf.HartreeFock.cUHF_s.MF.nuc_rep}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{nuc\_rep}}}{}{}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The nuclear repulsion value

\end{description}\end{quote}

\end{fulllineitems}

\index{random\_guess() (hf.HartreeFock.cUHF\_s.MF method)@\spxentry{random\_guess()}\spxextra{hf.HartreeFock.cUHF\_s.MF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cUHF_s:hf.HartreeFock.cUHF_s.MF.random_guess}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{random\_guess}}}{}{}
A function that creates a matrix with random values that can be used as an initial guess
for the SCF calculations.

To use this guess:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{hf}\PYG{n+nn}{.}\PYG{n+nn}{HartreeFock} \PYG{k}{import} \PYG{o}{*}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{h3} \PYG{o}{=} \PYG{n}{gto}\PYG{o}{.}\PYG{n}{M}\PYG{p}{(}\PYG{n}{atom} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{h 0 0 0; h 0 0.86602540378 0.5; h 0 0 1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{spin} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{basis} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cc\PYGZhy{}pvdz}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x} \PYG{o}{=} \PYG{n}{cUHF\PYGZus{}s}\PYG{o}{.}\PYG{n}{MF}\PYG{p}{(}\PYG{n}{h3}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{guess} \PYG{o}{=} \PYG{n}{x}\PYG{o}{.}\PYG{n}{random\PYGZus{}guess}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x}\PYG{o}{.}\PYG{n}{get\PYGZus{}scf\PYGZus{}solution}\PYG{p}{(}\PYG{n}{guess}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
A random unitary matrix.

\end{description}\end{quote}

\end{fulllineitems}

\index{scf() (hf.HartreeFock.cUHF\_s.MF method)@\spxentry{scf()}\spxextra{hf.HartreeFock.cUHF\_s.MF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cUHF_s:hf.HartreeFock.cUHF_s.MF.scf}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{scf}}}{\emph{initial\_guess=None}, \emph{convergence=1e-12}, \emph{diis=True}}{}
Performs a self consistent field calculation to find the lowest UHF energy.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{initial\_guess}} \textendash{} Random initial guess, if none is given the Core Hamiltonian is used.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{convergence}} \textendash{} Set the convergence criterion. If none is given, 1e-12 is used.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{diis}} \textendash{} Accelerates the convergence, default is true.

\end{itemize}

\item[{Returns}] \leavevmode
The scf energy, number of iterations, the mo coefficients, the last density and the last fock matrices

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\phantomsection\label{\detokenize{cUHF_b:module-hf.HartreeFock.cUHF_b}}\index{hf.HartreeFock.cUHF\_b (module)@\spxentry{hf.HartreeFock.cUHF\_b}\spxextra{module}}

\chapter{Constrained unrestricted Hartree Fock by P. Bultinck}
\label{\detokenize{cUHF_b:constrained-unrestricted-hartree-fock-by-p-bultinck}}\label{\detokenize{cUHF_b::doc}}
This class is used to calculate the ROHF energy for a given molecule and the number of electrons of that molecule,
using a constrained version of unrestricted Hartree Fock. This constraint is an idea from professor P. Bultinck, where
the alpha and beta MO’s are made equal for the closed shell part of the system.
Several options are available to make sure you get the lowest energy from your calculation, as well as some useful
functions to get intermediate values such as MO coefficients, density and fock matrices.
\index{MF (class in hf.HartreeFock.cUHF\_b)@\spxentry{MF}\spxextra{class in hf.HartreeFock.cUHF\_b}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cUHF_b:hf.HartreeFock.cUHF_b.MF}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{hf.HartreeFock.cUHF\_b.}}\sphinxbfcode{\sphinxupquote{MF}}}{\emph{molecule}, \emph{number\_of\_electrons}, \emph{int\_method='pyscf'}}{}
Input is a molecule and the number of electrons.

Molecules are made in pySCF/psi4 and calculations are performed as follows, eg.:
The following snippet prints and returns UHF energy of h\_3
and the number of iterations needed to get this value.

For a normal scf calculation your input looks like the following example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{hf}\PYG{n+nn}{.}\PYG{n+nn}{HartreeFock} \PYG{k}{import} \PYG{o}{*}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{h3} \PYG{o}{=} \PYG{n}{gto}\PYG{o}{.}\PYG{n}{M}\PYG{p}{(}\PYG{n}{atom} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{h 0 0 0; h 0 0.86602540378 0.5; h 0 0 1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{spin} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{basis} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cc\PYGZhy{}pvdz}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x} \PYG{o}{=} \PYG{n}{cUHF\PYGZus{}b}\PYG{o}{.}\PYG{n}{MF}\PYG{p}{(}\PYG{n}{h3}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x}\PYG{o}{.}\PYG{n}{get\PYGZus{}scf\PYGZus{}solution}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}
\index{diis() (hf.HartreeFock.cUHF\_b.MF method)@\spxentry{diis()}\spxextra{hf.HartreeFock.cUHF\_b.MF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cUHF_b:hf.HartreeFock.cUHF_b.MF.diis}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{diis}}}{\emph{initial\_guess=None}, \emph{convergence=1e-12}}{}
When needed, DIIS can be used to speed up the UHF calculations by reducing the needed iterations.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{initial\_guess}} \textendash{} Initial guess for the scf procedure. None specified: core Hamiltonian.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{convergence}} \textendash{} Set the convergence criterion. If none is given, 1e-12 is used.

\end{itemize}

\item[{Returns}] \leavevmode
scf energy, number of iterations, mo coefficients, last density matrix, last fock matrix

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_constrained\_mo() (hf.HartreeFock.cUHF\_b.MF method)@\spxentry{get\_constrained\_mo()}\spxextra{hf.HartreeFock.cUHF\_b.MF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cUHF_b:hf.HartreeFock.cUHF_b.MF.get_constrained_mo}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_constrained\_mo}}}{\emph{i=-1}}{}
Gets the constrained mo coefficients of the converged solution.
Alpha coefficients in the first matrix, beta coefficients in the second.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{i}} \textendash{} Iteration of which the mo coefficients are given. If None, the ones of the last iteration are given.

\item[{Returns}] \leavevmode
The (last) mo coefficients

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_dens() (hf.HartreeFock.cUHF\_b.MF method)@\spxentry{get\_dens()}\spxextra{hf.HartreeFock.cUHF\_b.MF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cUHF_b:hf.HartreeFock.cUHF_b.MF.get_dens}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_dens}}}{\emph{i=-1}}{}
Gets the last density matrix of the converged solution.
Alpha density in the first matrix, beta density in the second.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{i}} \textendash{} Iteration of which the densities are given. If None, the ones of the last iteration are given.

\item[{Returns}] \leavevmode
The (last) density matrix.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_fock() (hf.HartreeFock.cUHF\_b.MF method)@\spxentry{get\_fock()}\spxextra{hf.HartreeFock.cUHF\_b.MF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cUHF_b:hf.HartreeFock.cUHF_b.MF.get_fock}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_fock}}}{\emph{i=-1}}{}
Gets the fock matrix of the converged solution.
Alpha Fock matrix first, beta Fock matrix second.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{i}} \textendash{} Iteration of which the focks are given. If None, the ones of the last iteration are given.

\item[{Returns}] \leavevmode
The (last) Fock matrix.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_last\_dens() (hf.HartreeFock.cUHF\_b.MF method)@\spxentry{get\_last\_dens()}\spxextra{hf.HartreeFock.cUHF\_b.MF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cUHF_b:hf.HartreeFock.cUHF_b.MF.get_last_dens}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_last\_dens}}}{}{}
Gets the last density matrix of the converged solution.
Alpha density in the first matrix, beta density in the second.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The last density matrix.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_last\_fock() (hf.HartreeFock.cUHF\_b.MF method)@\spxentry{get\_last\_fock()}\spxextra{hf.HartreeFock.cUHF\_b.MF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cUHF_b:hf.HartreeFock.cUHF_b.MF.get_last_fock}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_last\_fock}}}{}{}
Gets the last fock matrix of the converged solution.
Alpha Fock matrix first, beta Fock matrix second.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The last Fock matrix.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_mo() (hf.HartreeFock.cUHF\_b.MF method)@\spxentry{get\_mo()}\spxextra{hf.HartreeFock.cUHF\_b.MF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cUHF_b:hf.HartreeFock.cUHF_b.MF.get_mo}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_mo}}}{\emph{i=-1}}{}
Gets the mo coefficients of the converged solution.
Alpha coefficients in the first matrix, beta coefficients in the second.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{i}} \textendash{} Iteration of which the mo coefficients are given. If None, the ones of the last iteration are given.

\item[{Returns}] \leavevmode
The (last) mo coefficients

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_mo\_coeff() (hf.HartreeFock.cUHF\_b.MF method)@\spxentry{get\_mo\_coeff()}\spxextra{hf.HartreeFock.cUHF\_b.MF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cUHF_b:hf.HartreeFock.cUHF_b.MF.get_mo_coeff}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_mo\_coeff}}}{}{}
Gets the mo coefficients of the converged solution.
Alpha coefficients in the first matrix, beta coefficients in the second.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The mo coefficients

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_one\_e() (hf.HartreeFock.cUHF\_b.MF method)@\spxentry{get\_one\_e()}\spxextra{hf.HartreeFock.cUHF\_b.MF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cUHF_b:hf.HartreeFock.cUHF_b.MF.get_one_e}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_one\_e}}}{}{}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The one electron integral matrix: T + V

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_orth\_fock() (hf.HartreeFock.cUHF\_b.MF method)@\spxentry{get\_orth\_fock()}\spxextra{hf.HartreeFock.cUHF\_b.MF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cUHF_b:hf.HartreeFock.cUHF_b.MF.get_orth_fock}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_orth\_fock}}}{\emph{i=-1}}{}
Gets the orthonormal fock matrix of the converged solution.
Alpha Fock matrix first, beta Fock matrix second.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{i}} \textendash{} Iteration of which the focks are given. If None, the ones of the last iteration are given.

\item[{Returns}] \leavevmode
The (last) orthonormal Fock matrix.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_ovlp() (hf.HartreeFock.cUHF\_b.MF method)@\spxentry{get\_ovlp()}\spxextra{hf.HartreeFock.cUHF\_b.MF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cUHF_b:hf.HartreeFock.cUHF_b.MF.get_ovlp}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_ovlp}}}{}{}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The overlap matrix

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_scf\_solution() (hf.HartreeFock.cUHF\_b.MF method)@\spxentry{get\_scf\_solution()}\spxextra{hf.HartreeFock.cUHF\_b.MF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cUHF_b:hf.HartreeFock.cUHF_b.MF.get_scf_solution}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_scf\_solution}}}{\emph{guess=None}, \emph{convergence=1e-12}}{}
Prints the number of iterations and the converged scf energy.
Also prints the expectation value of S\_z, S\textasciicircum{}2 and the multiplicity.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{guess}} \textendash{} Initial scf guess

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{convergence}} \textendash{} Set the convergence criterion. If none is given, 1e-12 is used.

\end{itemize}

\item[{Returns}] \leavevmode
The converged scf energy.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_scf\_solution\_diis() (hf.HartreeFock.cUHF\_b.MF method)@\spxentry{get\_scf\_solution\_diis()}\spxextra{hf.HartreeFock.cUHF\_b.MF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cUHF_b:hf.HartreeFock.cUHF_b.MF.get_scf_solution_diis}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_scf\_solution\_diis}}}{\emph{guess=None}, \emph{convergence=1e-12}}{}
Prints the number of iterations and the converged diis energy.
Also prints the expectation value of S\_z, S\textasciicircum{}2 and the multiplicity.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{guess}} \textendash{} The initial guess. If none is specified, core Hamiltonian.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{convergence}} \textendash{} Set the convergence criterion. If none is given, 1e-12 is used.

\end{itemize}

\item[{Returns}] \leavevmode
The converged diis energy.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_two\_e() (hf.HartreeFock.cUHF\_b.MF method)@\spxentry{get\_two\_e()}\spxextra{hf.HartreeFock.cUHF\_b.MF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cUHF_b:hf.HartreeFock.cUHF_b.MF.get_two_e}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_two\_e}}}{}{}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The electron repulsion interaction tensor

\end{description}\end{quote}

\end{fulllineitems}

\index{nuc\_rep() (hf.HartreeFock.cUHF\_b.MF method)@\spxentry{nuc\_rep()}\spxextra{hf.HartreeFock.cUHF\_b.MF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cUHF_b:hf.HartreeFock.cUHF_b.MF.nuc_rep}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{nuc\_rep}}}{}{}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The nuclear repulsion value

\end{description}\end{quote}

\end{fulllineitems}

\index{random\_guess() (hf.HartreeFock.cUHF\_b.MF method)@\spxentry{random\_guess()}\spxextra{hf.HartreeFock.cUHF\_b.MF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cUHF_b:hf.HartreeFock.cUHF_b.MF.random_guess}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{random\_guess}}}{}{}
A function that creates a matrix with random values that can be used as an initial guess
for the SCF calculations.

To use this guess:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{hf}\PYG{n+nn}{.}\PYG{n+nn}{HartreeFock} \PYG{k}{import} \PYG{o}{*}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{h3} \PYG{o}{=} \PYG{n}{gto}\PYG{o}{.}\PYG{n}{M}\PYG{p}{(}\PYG{n}{atom} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{h 0 0 0; h 0 0.86602540378 0.5; h 0 0 1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{spin} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{basis} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cc\PYGZhy{}pvdz}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x} \PYG{o}{=} \PYG{n}{cUHF\PYGZus{}b}\PYG{p}{(}\PYG{n}{h3}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{guess} \PYG{o}{=} \PYG{n}{x}\PYG{o}{.}\PYG{n}{random\PYGZus{}guess}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x}\PYG{o}{.}\PYG{n}{get\PYGZus{}scf\PYGZus{}solution}\PYG{p}{(}\PYG{n}{guess}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
A random hermitian matrix.

\end{description}\end{quote}

\end{fulllineitems}

\index{scf() (hf.HartreeFock.cUHF\_b.MF method)@\spxentry{scf()}\spxextra{hf.HartreeFock.cUHF\_b.MF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cUHF_b:hf.HartreeFock.cUHF_b.MF.scf}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{scf}}}{\emph{initial\_guess=None}, \emph{convergence=1e-12}}{}
Performs a self consistent field calculation to find the lowest UHF energy.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{initial\_guess}} \textendash{} Set the convergence criterion. If none is given, 1e-12 is used.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{convergence}} \textendash{} Set the convergence criterion. If none is given, 1e-12 is used.

\end{itemize}

\item[{Returns}] \leavevmode
The scf energy, number of iterations, the mo coefficients, the last density and the last fock matrices

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\phantomsection\label{\detokenize{GHF:module-hf.HartreeFock.GHF}}\index{hf.HartreeFock.GHF (module)@\spxentry{hf.HartreeFock.GHF}\spxextra{module}}

\chapter{Generalised Hartree Fock, by means of SCF procedure}
\label{\detokenize{GHF:generalised-hartree-fock-by-means-of-scf-procedure}}\label{\detokenize{GHF::doc}}
This class creates a generalised Hartree-Fock object which can be used for scf calculations. Different initial guesses
are provided as well as the option to perform a stability analysis.
The molecule has to be created in pySCF:
molecule = gto.M(atom = geometry, spin = diff. in alpha and beta electrons, basis = basis set)
\index{MF (class in hf.HartreeFock.GHF)@\spxentry{MF}\spxextra{class in hf.HartreeFock.GHF}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GHF:hf.HartreeFock.GHF.MF}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{hf.HartreeFock.GHF.}}\sphinxbfcode{\sphinxupquote{MF}}}{\emph{molecule}, \emph{number\_of\_electrons}, \emph{int\_method='pyscf'}}{}
Input is a molecule and the number of electrons.

Molecules are made in pySCF and calculations are performed as follows, eg.:
The following snippet prints and returns UHF energy of h3
and the number of iterations needed to get this value.

For a normal scf calculation your input looks like the following example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{hf}\PYG{n+nn}{.}\PYG{n+nn}{HartreeFock} \PYG{k}{import} \PYG{o}{*}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{h3} \PYG{o}{=} \PYG{n}{gto}\PYG{o}{.}\PYG{n}{M}\PYG{p}{(}\PYG{n}{atom} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{h 0 0 0; h 0 0.86602540378 0.5; h 0 0 1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{spin} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{basis} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cc\PYGZhy{}pvdz}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x} \PYG{o}{=} \PYG{n}{GHF}\PYG{o}{.}\PYG{n}{MF}\PYG{p}{(}\PYG{n}{h3}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x}\PYG{o}{.} \PYG{n}{get\PYGZus{}scf\PYGZus{}solution}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{Number of iterations: 81}
\PYG{g+go}{Converged SCF energy in Hartree: \PYGZhy{}1.5062743202607725 (Real GHF)}
\end{sphinxVerbatim}
\index{diis() (hf.HartreeFock.GHF.MF method)@\spxentry{diis()}\spxextra{hf.HartreeFock.GHF.MF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GHF:hf.HartreeFock.GHF.MF.diis}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{diis}}}{\emph{guess=None}, \emph{convergence=1e-12}, \emph{complex\_method=False}}{}
The DIIS method is an alternative to the standard scf procedure. It reduces the number of iterations needed to
find a solution. The same guesses can be used as for a standard scf calculation. Stability analysis can be
done as well.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{convergence}} \textendash{} Set the convergence criterion. If none is given, 1e-12 is used.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{guess}} \textendash{} The initial guess matrix, if none is specified, the spin blocked core Hamiltonian is used.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{complex\_method}} \textendash{} Specify whether or not you want to work in the complex space. Default is real.

\end{itemize}

\item[{Returns}] \leavevmode
scf\_energy, iterations, mo coefficients, last density matrix \& last Fock matrix

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_hessian() (hf.HartreeFock.GHF.MF method)@\spxentry{get\_hessian()}\spxextra{hf.HartreeFock.GHF.MF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GHF:hf.HartreeFock.GHF.MF.get_hessian}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_hessian}}}{}{}
After stability analysis is performed, the hessian is stored and can be used for further studying.
:return: The Hessian matrix

\end{fulllineitems}

\index{get\_last\_dens() (hf.HartreeFock.GHF.MF method)@\spxentry{get\_last\_dens()}\spxextra{hf.HartreeFock.GHF.MF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GHF:hf.HartreeFock.GHF.MF.get_last_dens}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_last\_dens}}}{}{}
Gets the last density matrix of the converged solution.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The last density matrix.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_last\_fock() (hf.HartreeFock.GHF.MF method)@\spxentry{get\_last\_fock()}\spxextra{hf.HartreeFock.GHF.MF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GHF:hf.HartreeFock.GHF.MF.get_last_fock}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_last\_fock}}}{}{}
Gets the last fock matrix of the converged solution.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The last Fock matrix.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_mo\_coeff() (hf.HartreeFock.GHF.MF method)@\spxentry{get\_mo\_coeff()}\spxextra{hf.HartreeFock.GHF.MF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GHF:hf.HartreeFock.GHF.MF.get_mo_coeff}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_mo\_coeff}}}{}{}
Gets the mo coefficients of the converged solution.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The mo coefficients

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_one\_e() (hf.HartreeFock.GHF.MF method)@\spxentry{get\_one\_e()}\spxextra{hf.HartreeFock.GHF.MF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GHF:hf.HartreeFock.GHF.MF.get_one_e}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_one\_e}}}{}{}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The one electron integral matrix: T + V

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_ovlp() (hf.HartreeFock.GHF.MF method)@\spxentry{get\_ovlp()}\spxextra{hf.HartreeFock.GHF.MF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GHF:hf.HartreeFock.GHF.MF.get_ovlp}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_ovlp}}}{}{}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The overlap matrix

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_scf\_solution() (hf.HartreeFock.GHF.MF method)@\spxentry{get\_scf\_solution()}\spxextra{hf.HartreeFock.GHF.MF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GHF:hf.HartreeFock.GHF.MF.get_scf_solution}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_scf\_solution}}}{\emph{guess=None}, \emph{convergence=1e-12}, \emph{complex\_method=False}}{}
Prints the number of iterations and the converged scf energy.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{guess}} \textendash{} Initial guess for scf. If none is specified: expanded core Hamiltonian.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{convergence}} \textendash{} Set the convergence criterion. If none is given, 1e-12 is used.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{complex\_method}} \textendash{} Specify whether or not you want to work in the complex space. Default is real.

\end{itemize}

\item[{Returns}] \leavevmode
The converged scf energy.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_scf\_solution\_diis() (hf.HartreeFock.GHF.MF method)@\spxentry{get\_scf\_solution\_diis()}\spxextra{hf.HartreeFock.GHF.MF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GHF:hf.HartreeFock.GHF.MF.get_scf_solution_diis}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_scf\_solution\_diis}}}{\emph{guess=None}, \emph{convergence=1e-12}, \emph{complex\_method=False}}{}
Prints the number of iterations and the converged energy after a diis calculation. Guesses can also be specified
just like with a normal scf calculation.

Example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{hf}\PYG{n+nn}{.}\PYG{n+nn}{HartreeFock} \PYG{k}{import} \PYG{o}{*}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{h3} \PYG{o}{=} \PYG{n}{gto}\PYG{o}{.}\PYG{n}{M}\PYG{p}{(}\PYG{n}{atom} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{h 0 0 0; h 0 0.86602540378 0.5; h 0 0 1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{spin} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{basis} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cc\PYGZhy{}pvdz}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x} \PYG{o}{=} \PYG{n}{GHF}\PYG{o}{.}\PYG{n}{MF}\PYG{p}{(}\PYG{n}{h3}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{guess} \PYG{o}{=} \PYG{n}{x}\PYG{o}{.}\PYG{n}{random\PYGZus{}guess}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x}\PYG{o}{.}\PYG{n}{get\PYGZus{}scf\PYGZus{}solution\PYGZus{}diis}\PYG{p}{(}\PYG{n}{guess}\PYG{p}{)}
\PYG{g+go}{Number of iterations: 23}
\PYG{g+go}{Converged SCF energy in Hartree: \PYGZhy{}1.5062743202915496 (Real GHF)}
\end{sphinxVerbatim}

Without DIIS, 81 iterations are needed to find this solution.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{guess}} \textendash{} Initial guess for scf. None specified: expanded core Hamiltonian

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{convergence}} \textendash{} Set the convergence criterion. If none is given, 1e-12 is used.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{complex\_method}} \textendash{} Specify whether or not you want to work in the complex space. Default is real.cd

\end{itemize}

\item[{Returns}] \leavevmode
The converged scf energy.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_two\_e() (hf.HartreeFock.GHF.MF method)@\spxentry{get\_two\_e()}\spxextra{hf.HartreeFock.GHF.MF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GHF:hf.HartreeFock.GHF.MF.get_two_e}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_two\_e}}}{}{}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The electron repulsion interaction tensor

\end{description}\end{quote}

\end{fulllineitems}

\index{nuc\_rep() (hf.HartreeFock.GHF.MF method)@\spxentry{nuc\_rep()}\spxextra{hf.HartreeFock.GHF.MF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GHF:hf.HartreeFock.GHF.MF.nuc_rep}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{nuc\_rep}}}{}{}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The nuclear repulsion value

\end{description}\end{quote}

\end{fulllineitems}

\index{random\_guess() (hf.HartreeFock.GHF.MF method)@\spxentry{random\_guess()}\spxextra{hf.HartreeFock.GHF.MF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GHF:hf.HartreeFock.GHF.MF.random_guess}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{random\_guess}}}{}{}
A function that creates a matrix with random values that can be used as an initial guess
for the SCF calculations.

To use this guess:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{hf}\PYG{n+nn}{.}\PYG{n+nn}{HartreeFock} \PYG{k}{import} \PYG{o}{*}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{h3} \PYG{o}{=} \PYG{n}{gto}\PYG{o}{.}\PYG{n}{M}\PYG{p}{(}\PYG{n}{atom} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{h 0 0 0; h 0 0.86602540378 0.5; h 0 0 1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{spin} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{basis} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cc\PYGZhy{}pvdz}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x} \PYG{o}{=} \PYG{n}{GHF}\PYG{o}{.}\PYG{n}{MF}\PYG{p}{(}\PYG{n}{h3}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{guess} \PYG{o}{=} \PYG{n}{x}\PYG{o}{.}\PYG{n}{random\PYGZus{}guess}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x}\PYG{o}{.}\PYG{n}{get\PYGZus{}scf\PYGZus{}solution}\PYG{p}{(}\PYG{n}{guess}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
A random hermitian matrix.

\end{description}\end{quote}

\end{fulllineitems}

\index{scf() (hf.HartreeFock.GHF.MF method)@\spxentry{scf()}\spxextra{hf.HartreeFock.GHF.MF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GHF:hf.HartreeFock.GHF.MF.scf}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{scf}}}{\emph{guess=None}, \emph{convergence=1e-12}, \emph{complex\_method=False}}{}
This function performs the SCF calculation by using the generalised Hartree-Fock formulas. Since we’re working
in the real class, all values throughout are real. For complex, see the “complex\_GHF” class.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{guess}} \textendash{} Initial guess to start SCF. If none is given, core hamiltonian will be used.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{convergence}} \textendash{} Set the convergence criterion. If none is given, 1e-12 is used.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{complex\_method}} \textendash{} Specify whether or not you want to work in the complex space. Default is real.

\end{itemize}

\item[{Returns}] \leavevmode
scf\_energy, iterations, mo coefficients, last density matrix \& last Fock matrix

\end{description}\end{quote}

\end{fulllineitems}

\index{stability\_analysis() (hf.HartreeFock.GHF.MF method)@\spxentry{stability\_analysis()}\spxextra{hf.HartreeFock.GHF.MF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GHF:hf.HartreeFock.GHF.MF.stability_analysis}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{stability\_analysis}}}{\emph{method}, \emph{step\_size=0.0001}}{}
Internal stability analysis to verify whether the wave function is stable within the space of the used method.
:param method: Indicate whether you want to check the internal or external stability of the wave function. Can
be internal or external.
:param step\_size: Step size for orbital rotation. standard is 1e-4.
:return: In case of internal stability analysis, it returns a new set of coefficients.

\end{fulllineitems}

\index{unitary\_rotation\_guess() (hf.HartreeFock.GHF.MF method)@\spxentry{unitary\_rotation\_guess()}\spxextra{hf.HartreeFock.GHF.MF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GHF:hf.HartreeFock.GHF.MF.unitary_rotation_guess}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{unitary\_rotation\_guess}}}{\emph{init=None}}{}
A function that creates an initial guess matrix by performing a unitary transformation on the core Hamiltonian
matrix.

To use this guess:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{hf}\PYG{n+nn}{.}\PYG{n+nn}{HartreeFock} \PYG{k}{import} \PYG{o}{*}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{h3} \PYG{o}{=} \PYG{n}{gto}\PYG{o}{.}\PYG{n}{M}\PYG{p}{(}\PYG{n}{atom} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{h 0 0 0; h 0 0.86602540378 0.5; h 0 0 1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{spin} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{basis} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cc\PYGZhy{}pvdz}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x} \PYG{o}{=} \PYG{n}{GHF}\PYG{o}{.}\PYG{n}{MF}\PYG{p}{(}\PYG{n}{h3}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{guess} \PYG{o}{=} \PYG{n}{x}\PYG{o}{.}\PYG{n}{unitary\PYGZus{}rotation\PYGZus{}guess}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x}\PYG{o}{.}\PYG{n}{get\PYGZus{}scf\PYGZus{}solution}\PYG{p}{(}\PYG{n}{guess}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
A rotated guess matrix.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\phantomsection\label{\detokenize{SCF_functions:module-hf.utilities.SCF_functions}}\index{hf.utilities.SCF\_functions (module)@\spxentry{hf.utilities.SCF\_functions}\spxextra{module}}

\chapter{Useful functions for SCF procedure}
\label{\detokenize{SCF_functions:useful-functions-for-scf-procedure}}\label{\detokenize{SCF_functions::doc}}
A number of functions used throughout the UHF and RHF calculations are summarised here.
\index{density\_matrix() (in module hf.utilities.SCF\_functions)@\spxentry{density\_matrix()}\spxextra{in module hf.utilities.SCF\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{SCF_functions:hf.utilities.SCF_functions.density_matrix}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{hf.utilities.SCF\_functions.}}\sphinxbfcode{\sphinxupquote{density\_matrix}}}{\emph{f\_matrix}, \emph{occ}, \emph{trans}}{}~\begin{itemize}
\item {} 
density() creates a density matrix from a fock matrix and the number of occupied orbitals.

\item {} 
Input is a fock matrix, the number of occupied orbitals, which can be separate for alpha and beta in case of UHF.
And a transformation matrix X.

\end{itemize}

\end{fulllineitems}

\index{get\_integrals\_psi4() (in module hf.utilities.SCF\_functions)@\spxentry{get\_integrals\_psi4()}\spxextra{in module hf.utilities.SCF\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{SCF_functions:hf.utilities.SCF_functions.get_integrals_psi4}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{hf.utilities.SCF\_functions.}}\sphinxbfcode{\sphinxupquote{get\_integrals\_psi4}}}{\emph{mol}}{}
A function to calculate your integrals \& nuclear repulsion with psi4.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{mol}} \textendash{} Psi4 instance

\item[{Returns}] \leavevmode
overlap, core hamiltonian, eri tensor and nuclear repulsion

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_integrals\_pyscf() (in module hf.utilities.SCF\_functions)@\spxentry{get\_integrals\_pyscf()}\spxextra{in module hf.utilities.SCF\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{SCF_functions:hf.utilities.SCF_functions.get_integrals_pyscf}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{hf.utilities.SCF\_functions.}}\sphinxbfcode{\sphinxupquote{get\_integrals\_pyscf}}}{\emph{molecule}}{}
A function to calculate your integrals \& nuclear repulsion with pyscf.

\end{fulllineitems}

\index{trans\_matrix() (in module hf.utilities.SCF\_functions)@\spxentry{trans\_matrix()}\spxextra{in module hf.utilities.SCF\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{SCF_functions:hf.utilities.SCF_functions.trans_matrix}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{hf.utilities.SCF\_functions.}}\sphinxbfcode{\sphinxupquote{trans\_matrix}}}{\emph{overlap}}{}~\begin{itemize}
\item {} 
Define a transformation matrix X, used to orthogonalize different matrices throughout the calculation.

\item {} 
Input should be an overlap matrix.

\end{itemize}

\end{fulllineitems}

\index{uhf\_fock\_matrix() (in module hf.utilities.SCF\_functions)@\spxentry{uhf\_fock\_matrix()}\spxextra{in module hf.utilities.SCF\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{SCF_functions:hf.utilities.SCF_functions.uhf_fock_matrix}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{hf.utilities.SCF\_functions.}}\sphinxbfcode{\sphinxupquote{uhf\_fock\_matrix}}}{\emph{density\_matrix\_1}, \emph{density\_matrix\_2}, \emph{one\_electron}, \emph{two\_electron}}{}~\begin{itemize}
\item {} 
calculate a fock matrix from a given alpha and beta density matrix

\item {} 
fock alpha if 1 = alpha and 2 = beta and vice versa

\item {} 
input is the density matrix for alpha and beta, a one electron matrix and a two electron tensor.

\end{itemize}

\end{fulllineitems}

\index{uhf\_scf\_energy() (in module hf.utilities.SCF\_functions)@\spxentry{uhf\_scf\_energy()}\spxextra{in module hf.utilities.SCF\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{SCF_functions:hf.utilities.SCF_functions.uhf_scf_energy}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{hf.utilities.SCF\_functions.}}\sphinxbfcode{\sphinxupquote{uhf\_scf\_energy}}}{\emph{density\_matrix\_a}, \emph{density\_matrix\_b}, \emph{fock\_a}, \emph{fock\_b}, \emph{one\_electron}}{}~\begin{itemize}
\item {} 
calculate the scf energy value from a given density matrix and a given fock matrix for both alpha and beta,
so 4 matrices in total.

\item {} 
then calculate the initial electronic energy and put it into an array

\item {} 
input is the density matrices for alpha and beta, the fock matrices for alpha and beta and lastly a one electron
matrix.

\end{itemize}

\end{fulllineitems}

\phantomsection\label{\detokenize{spin:module-hf.utilities.spin}}\index{hf.utilities.spin (module)@\spxentry{hf.utilities.spin}\spxextra{module}}

\chapter{Functions to calculate spin expectation values}
\label{\detokenize{spin:functions-to-calculate-spin-expectation-values}}\label{\detokenize{spin::doc}}
This file contains functions that calculate the expectation values of the different spin operators.
\index{ghf() (in module hf.utilities.spin)@\spxentry{ghf()}\spxextra{in module hf.utilities.spin}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spin:hf.utilities.spin.ghf}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{hf.utilities.spin.}}\sphinxbfcode{\sphinxupquote{ghf}}}{\emph{coeff}, \emph{n\_e}, \emph{trans}}{}
A function used to calculate the spin expectation values in the generalised hartree fock formalism.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{coeff}} \textendash{} The generalised MO coefficients

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{n\_e}} \textendash{} number of electrons

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{trans}} \textendash{} transformation matrix, eg.: S\textasciicircum{}(-1/2)

\end{itemize}

\item[{Returns}] \leavevmode
The expectation values of S\_z, S\textasciicircum{}2 and the multiplicity (2S+1)

\end{description}\end{quote}

\end{fulllineitems}

\index{uhf() (in module hf.utilities.spin)@\spxentry{uhf()}\spxextra{in module hf.utilities.spin}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spin:hf.utilities.spin.uhf}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{hf.utilities.spin.}}\sphinxbfcode{\sphinxupquote{uhf}}}{\emph{occ\_a}, \emph{occ\_b}, \emph{coeff\_a}, \emph{coeff\_b}, \emph{overlap}}{}
A function used to calculate the spin expectation values in the unrestricted hartree fock formalism.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{occ\_a}} \textendash{} number of occupied alpha orbitals

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{occ\_b}} \textendash{} number of occupied beta orbitals

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{coeff\_a}} \textendash{} MO coefficients of alpha orbitals

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{coeff\_b}} \textendash{} MO coefficients of beta orbitals

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{overlap}} \textendash{} overlap matrix of the molecule

\end{itemize}

\item[{Returns}] \leavevmode
S\textasciicircum{}2, S\_z and spin multiplicity

\end{description}\end{quote}

\end{fulllineitems}

\phantomsection\label{\detokenize{transform:module-hf.utilities.transform}}\index{hf.utilities.transform (module)@\spxentry{hf.utilities.transform}\spxextra{module}}

\chapter{Functions to deal with matrix and tensor transformations.}
\label{\detokenize{transform:functions-to-deal-with-matrix-and-tensor-transformations}}\label{\detokenize{transform::doc}}
This file contains functions that calculate the expectation values of the different spin operators.
\index{expand\_matrix() (in module hf.utilities.transform)@\spxentry{expand\_matrix()}\spxextra{in module hf.utilities.transform}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{transform:hf.utilities.transform.expand_matrix}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{hf.utilities.transform.}}\sphinxbfcode{\sphinxupquote{expand\_matrix}}}{\emph{matrix}}{}
Expand a matrix to spinor basis.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{matrix}} \textendash{} a matrix.

\item[{Returns}] \leavevmode
a matrix double the size, where blocks of zero’s are added top right and bottom left.

\end{description}\end{quote}

\end{fulllineitems}

\index{expand\_tensor() (in module hf.utilities.transform)@\spxentry{expand\_tensor()}\spxextra{in module hf.utilities.transform}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{transform:hf.utilities.transform.expand_tensor}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{hf.utilities.transform.}}\sphinxbfcode{\sphinxupquote{expand\_tensor}}}{\emph{tensor}, \emph{complexity=False}}{}
Expand a given tensor to spinor basis representation.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{tensor}} \textendash{} The tensor, usually eri, that you wish to expand.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{complexity}} \textendash{} Is your tensor complex or not? Default is false.

\end{itemize}

\item[{Returns}] \leavevmode
a tensor where each dimension is doubled.

\end{description}\end{quote}

\end{fulllineitems}

\index{spin\_blocked() (in module hf.utilities.transform)@\spxentry{spin\_blocked()}\spxextra{in module hf.utilities.transform}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{transform:hf.utilities.transform.spin_blocked}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{hf.utilities.transform.}}\sphinxbfcode{\sphinxupquote{spin\_blocked}}}{\emph{block\_1}, \emph{block\_2}, \emph{block\_3}, \emph{block\_4}}{}
When creating the blocks of the density or fock matrix separately, this function is used to add them together,
and create the total density or Fock matrix in spin Blocked notation. Transforms four separate matrices to 1 big
matrix in spin-blocked notation.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
a density matrix in the spin-blocked notation

\end{description}\end{quote}

\end{fulllineitems}

\index{tensor\_basis\_transform() (in module hf.utilities.transform)@\spxentry{tensor\_basis\_transform()}\spxextra{in module hf.utilities.transform}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{transform:hf.utilities.transform.tensor_basis_transform}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{hf.utilities.transform.}}\sphinxbfcode{\sphinxupquote{tensor\_basis\_transform}}}{\emph{tensor}, \emph{matrix}}{}
Transform the two electron tensor to MO basis. Scales as N\textasciicircum{}5.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{tensor}} \textendash{} A tensor in it’s initial basis.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{matrix}} \textendash{} the transformation matrix.

\end{itemize}

\item[{Returns}] \leavevmode
The tensor in the basis of the transformation matrix.

\end{description}\end{quote}

\end{fulllineitems}

\phantomsection\label{\detokenize{tests:module-hf.tests.test_auth}}\index{hf.tests.test\_auth (module)@\spxentry{hf.tests.test\_auth}\spxextra{module}}

\chapter{Testing the RHF and UHF methods}
\label{\detokenize{tests:testing-the-rhf-and-uhf-methods}}\label{\detokenize{tests::doc}}
Simple tests to check whether or not the functions return the correct value.
\index{test\_diis\_real\_ghf() (in module hf.tests.test\_auth)@\spxentry{test\_diis\_real\_ghf()}\spxextra{in module hf.tests.test\_auth}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tests:hf.tests.test_auth.test_diis_real_ghf}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{hf.tests.test\_auth.}}\sphinxbfcode{\sphinxupquote{test\_diis\_real\_ghf}}}{}{}
Test whether diis gives the same energy in fewer iterations.

\end{fulllineitems}

\index{test\_diis\_rhf() (in module hf.tests.test\_auth)@\spxentry{test\_diis\_rhf()}\spxextra{in module hf.tests.test\_auth}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tests:hf.tests.test_auth.test_diis_rhf}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{hf.tests.test\_auth.}}\sphinxbfcode{\sphinxupquote{test\_diis\_rhf}}}{}{}
Test whether diis gives the same energy in fewer iterations.

\end{fulllineitems}

\index{test\_diis\_uhf() (in module hf.tests.test\_auth)@\spxentry{test\_diis\_uhf()}\spxextra{in module hf.tests.test\_auth}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tests:hf.tests.test_auth.test_diis_uhf}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{hf.tests.test\_auth.}}\sphinxbfcode{\sphinxupquote{test\_diis\_uhf}}}{}{}
Test whether diis gives the same energy in fewer iterations.

\end{fulllineitems}

\index{test\_extra\_e() (in module hf.tests.test\_auth)@\spxentry{test\_extra\_e()}\spxextra{in module hf.tests.test\_auth}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tests:hf.tests.test_auth.test_extra_e}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{hf.tests.test\_auth.}}\sphinxbfcode{\sphinxupquote{test\_extra\_e}}}{}{}
test\_extra\_e will test the UHF method, with the added option of first adding 2 electrons to the system and using
those coefficients for the actual system, by checking whether or not it returns the expected result.
The accuracy is 10\textasciicircum{}-6.

\end{fulllineitems}

\index{test\_one\_e() (in module hf.tests.test\_auth)@\spxentry{test\_one\_e()}\spxextra{in module hf.tests.test\_auth}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tests:hf.tests.test_auth.test_one_e}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{hf.tests.test\_auth.}}\sphinxbfcode{\sphinxupquote{test\_one\_e}}}{}{}
Test whether or not psi4 and pyscf give the same core Hamiltonian integrals.
:return:

\end{fulllineitems}

\index{test\_overlap() (in module hf.tests.test\_auth)@\spxentry{test\_overlap()}\spxextra{in module hf.tests.test\_auth}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tests:hf.tests.test_auth.test_overlap}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{hf.tests.test\_auth.}}\sphinxbfcode{\sphinxupquote{test\_overlap}}}{}{}
Test whether or not psi4 and pyscf give the same overlap integrals.

\end{fulllineitems}

\index{test\_pyscf\_vs\_psi4() (in module hf.tests.test\_auth)@\spxentry{test\_pyscf\_vs\_psi4()}\spxextra{in module hf.tests.test\_auth}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tests:hf.tests.test_auth.test_pyscf_vs_psi4}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{hf.tests.test\_auth.}}\sphinxbfcode{\sphinxupquote{test\_pyscf\_vs\_psi4}}}{}{}
Test a pyscf energy calculation vs a psi4 energy calculation.

\end{fulllineitems}

\index{test\_rhf() (in module hf.tests.test\_auth)@\spxentry{test\_rhf()}\spxextra{in module hf.tests.test\_auth}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tests:hf.tests.test_auth.test_rhf}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{hf.tests.test\_auth.}}\sphinxbfcode{\sphinxupquote{test\_rhf}}}{}{}
test\_RHF will test whether or not the RHF method returns the wanted result. The accuracy is 10\textasciicircum{}-11.

\end{fulllineitems}

\index{test\_stability() (in module hf.tests.test\_auth)@\spxentry{test\_stability()}\spxextra{in module hf.tests.test\_auth}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tests:hf.tests.test_auth.test_stability}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{hf.tests.test\_auth.}}\sphinxbfcode{\sphinxupquote{test\_stability}}}{}{}
test\_stability will test the UHF method, with stability analysis, by checking whether or not it returns
the expected result. The accuracy is 10\textasciicircum{}-6.

\end{fulllineitems}

\index{test\_tensor\_transform() (in module hf.tests.test\_auth)@\spxentry{test\_tensor\_transform()}\spxextra{in module hf.tests.test\_auth}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tests:hf.tests.test_auth.test_tensor_transform}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{hf.tests.test\_auth.}}\sphinxbfcode{\sphinxupquote{test\_tensor\_transform}}}{}{}
Test whether tensor transformation happens correctly.

\end{fulllineitems}

\index{test\_two\_e() (in module hf.tests.test\_auth)@\spxentry{test\_two\_e()}\spxextra{in module hf.tests.test\_auth}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tests:hf.tests.test_auth.test_two_e}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{hf.tests.test\_auth.}}\sphinxbfcode{\sphinxupquote{test\_two\_e}}}{}{}
Test whether or not psi4 and pyscf give the same two electron integrals.

\end{fulllineitems}

\index{test\_uhf() (in module hf.tests.test\_auth)@\spxentry{test\_uhf()}\spxextra{in module hf.tests.test\_auth}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tests:hf.tests.test_auth.test_uhf}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{hf.tests.test\_auth.}}\sphinxbfcode{\sphinxupquote{test\_uhf}}}{}{}
test\_UHF will test the regular UHF method, by checking whether or not it returns the expected result.
The accuracy is 10\textasciicircum{}-6.

\end{fulllineitems}



\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\let\bigletter\sphinxstyleindexlettergroup
\bigletter{h}
\item\relax\sphinxstyleindexentry{hf.HartreeFock.cUHF\_b}\sphinxstyleindexpageref{cUHF_b:\detokenize{module-hf.HartreeFock.cUHF_b}}
\item\relax\sphinxstyleindexentry{hf.HartreeFock.cUHF\_s}\sphinxstyleindexpageref{cUHF_s:\detokenize{module-hf.HartreeFock.cUHF_s}}
\item\relax\sphinxstyleindexentry{hf.HartreeFock.GHF}\sphinxstyleindexpageref{GHF:\detokenize{module-hf.HartreeFock.GHF}}
\item\relax\sphinxstyleindexentry{hf.HartreeFock.RHF}\sphinxstyleindexpageref{RHF:\detokenize{module-hf.HartreeFock.RHF}}
\item\relax\sphinxstyleindexentry{hf.HartreeFock.UHF}\sphinxstyleindexpageref{UHF:\detokenize{module-hf.HartreeFock.UHF}}
\item\relax\sphinxstyleindexentry{hf.tests.test\_auth}\sphinxstyleindexpageref{tests:\detokenize{module-hf.tests.test_auth}}
\item\relax\sphinxstyleindexentry{hf.utilities.SCF\_functions}\sphinxstyleindexpageref{SCF_functions:\detokenize{module-hf.utilities.SCF_functions}}
\item\relax\sphinxstyleindexentry{hf.utilities.spin}\sphinxstyleindexpageref{spin:\detokenize{module-hf.utilities.spin}}
\item\relax\sphinxstyleindexentry{hf.utilities.transform}\sphinxstyleindexpageref{transform:\detokenize{module-hf.utilities.transform}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}