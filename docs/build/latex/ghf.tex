%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{times}
\expandafter\ifx\csname T@LGR\endcsname\relax
\else
% LGR was declared as font encoding
  \substitutefont{LGR}{\rmdefault}{cmr}
  \substitutefont{LGR}{\sfdefault}{cmss}
  \substitutefont{LGR}{\ttdefault}{cmtt}
\fi
\expandafter\ifx\csname T@X2\endcsname\relax
  \expandafter\ifx\csname T@T2A\endcsname\relax
  \else
  % T2A was declared as font encoding
    \substitutefont{T2A}{\rmdefault}{cmr}
    \substitutefont{T2A}{\sfdefault}{cmss}
    \substitutefont{T2A}{\ttdefault}{cmtt}
  \fi
\else
% X2 was declared as font encoding
  \substitutefont{X2}{\rmdefault}{cmr}
  \substitutefont{X2}{\sfdefault}{cmss}
  \substitutefont{X2}{\ttdefault}{cmtt}
\fi


\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}
\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}



\title{GHF}
\date{Nov 22, 2019}
\release{0.1}
\author{Xeno De Vriendt}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}

\phantomsection\label{\detokenize{RHF:module-ghf.RHF}}\index{ghf.RHF (module)@\spxentry{ghf.RHF}\spxextra{module}}

\chapter{Restricted Hartree Fock, by means of SCF procedure}
\label{\detokenize{RHF:restricted-hartree-fock-by-means-of-scf-procedure}}\label{\detokenize{RHF::doc}}
This class is used to calculate the RHF energy of a given molecule and the number of electrons.
The molecule has to be created in pySCF:
molecule = gto.M(atom = geometry, spin = diff. in alpha and beta electrons, basis = basis set)
\index{RHF (class in ghf.RHF)@\spxentry{RHF}\spxextra{class in ghf.RHF}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{RHF:ghf.RHF.RHF}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{ghf.RHF.}}\sphinxbfcode{\sphinxupquote{RHF}}}{\emph{molecule}, \emph{number\_of\_electrons}}{}
Input is a molecule and the number of electrons.

Molecules are made in pySCF and calculations are performed as follows, eg.:
The following snippet prints and returns RHF energy of h\_2
and the number of iterations needed to get this value.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{h\PYGZus{}2} \PYG{o}{=} \PYG{n}{gto}\PYG{o}{.}\PYG{n}{M}\PYG{p}{(}\PYG{n}{atom} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{h 0 0 0; h 0 0 1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{spin} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{basis} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cc\PYGZhy{}pvdz}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x} \PYG{o}{=} \PYG{n}{RHF}\PYG{p}{(}\PYG{n}{h\PYGZus{}2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x}\PYG{o}{.}\PYG{n}{get\PYGZus{}scf\PYGZus{}solution}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{Number of iterations: 17}
\PYG{g+go}{Converged SCF energy in Hartree: \PYGZhy{}1.100153764878324 (RHF)}
\end{sphinxVerbatim}
\index{diis() (ghf.RHF.RHF method)@\spxentry{diis()}\spxextra{ghf.RHF.RHF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{RHF:ghf.RHF.RHF.diis}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{diis}}}{\emph{convergence=1e-12}}{}
When needed, DIIS can be used to speed up the RHF calculations by reducing the needed iterations.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{convergence}} \textendash{} Set the convergence criterion. If none is given, 1e-12 is used.

\item[{Returns}] \leavevmode
scf energy, number of iterations, mo coefficients, last density matrix, last fock matrix

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_last\_dens() (ghf.RHF.RHF method)@\spxentry{get\_last\_dens()}\spxextra{ghf.RHF.RHF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{RHF:ghf.RHF.RHF.get_last_dens}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_last\_dens}}}{}{}
Returns the last density matrix of the converged solution.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The last density matrix.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_last\_fock() (ghf.RHF.RHF method)@\spxentry{get\_last\_fock()}\spxextra{ghf.RHF.RHF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{RHF:ghf.RHF.RHF.get_last_fock}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_last\_fock}}}{}{}
Returns the last fock matrix of the converged solution.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The last Fock matrix.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_mo\_coeff() (ghf.RHF.RHF method)@\spxentry{get\_mo\_coeff()}\spxextra{ghf.RHF.RHF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{RHF:ghf.RHF.RHF.get_mo_coeff}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_mo\_coeff}}}{}{}
Returns mo coefficients of the converged solution.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The mo coefficients

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_one\_e() (ghf.RHF.RHF method)@\spxentry{get\_one\_e()}\spxextra{ghf.RHF.RHF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{RHF:ghf.RHF.RHF.get_one_e}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_one\_e}}}{}{}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The one electron integral matrix: T + V

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_ovlp() (ghf.RHF.RHF method)@\spxentry{get\_ovlp()}\spxextra{ghf.RHF.RHF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{RHF:ghf.RHF.RHF.get_ovlp}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_ovlp}}}{}{}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The overlap matrix

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_scf\_solution() (ghf.RHF.RHF method)@\spxentry{get\_scf\_solution()}\spxextra{ghf.RHF.RHF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{RHF:ghf.RHF.RHF.get_scf_solution}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_scf\_solution}}}{\emph{convergence=1e-12}}{}
Prints the number of iterations and the converged scf energy.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{convergence}} \textendash{} Set the convergence criterion. If none is given, 1e-12 is used.

\item[{Returns}] \leavevmode
the converged energy

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_scf\_solution\_diis() (ghf.RHF.RHF method)@\spxentry{get\_scf\_solution\_diis()}\spxextra{ghf.RHF.RHF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{RHF:ghf.RHF.RHF.get_scf_solution_diis}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_scf\_solution\_diis}}}{\emph{convergence=1e-12}}{}
Prints the number of iterations and the converged DIIS energy. The number of iterations will be lower than with
a normal scf, but the energy value will be the same. Example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{h2} \PYG{o}{=} \PYG{n}{gto}\PYG{o}{.}\PYG{n}{M}\PYG{p}{(}\PYG{n}{atom} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{h 0 0 0; h 1 0 0}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{basis} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cc\PYGZhy{}pvdz}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x} \PYG{o}{=} \PYG{n}{RHF}\PYG{p}{(}\PYG{n}{h2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x}\PYG{o}{.}\PYG{n}{get\PYGZus{}scf\PYGZus{}solution\PYGZus{}diis}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{Number of iterations: 9}
\PYG{g+go}{Converged SCF energy in Hartree: \PYGZhy{}1.100153764878446 (RHF)}
\end{sphinxVerbatim}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{convergence}} \textendash{} Set the convergence criterion. If none is given, 1e-12 is used.

\item[{Returns}] \leavevmode
The converged scf energy, using DIIS.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_two\_e() (ghf.RHF.RHF method)@\spxentry{get\_two\_e()}\spxextra{ghf.RHF.RHF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{RHF:ghf.RHF.RHF.get_two_e}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_two\_e}}}{}{}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The electron repulsion interaction tensor

\end{description}\end{quote}

\end{fulllineitems}

\index{nuc\_rep() (ghf.RHF.RHF method)@\spxentry{nuc\_rep()}\spxextra{ghf.RHF.RHF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{RHF:ghf.RHF.RHF.nuc_rep}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{nuc\_rep}}}{}{}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The nuclear repulsion value

\end{description}\end{quote}

\end{fulllineitems}

\index{scf() (ghf.RHF.RHF method)@\spxentry{scf()}\spxextra{ghf.RHF.RHF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{RHF:ghf.RHF.RHF.scf}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{scf}}}{\emph{convergence=1e-12}}{}
Performs a self consistent field calculation to find the lowest RHF energy.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{convergence}} \textendash{} Convergence criterion. If none is specified, 1e-12 is used.

\item[{Returns}] \leavevmode
number of iterations, scf energy, mo coefficients, last density matrix, last fock matrix

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\phantomsection\label{\detokenize{UHF:module-ghf.UHF}}\index{ghf.UHF (module)@\spxentry{ghf.UHF}\spxextra{module}}

\chapter{Unrestricted Hartree Fock, by means of SCF procedure}
\label{\detokenize{UHF:unrestricted-hartree-fock-by-means-of-scf-procedure}}\label{\detokenize{UHF::doc}}
This class is used to calculate the UHF energy for a given molecule and the number of electrons of that molecule.
Several options are available to make sure you get the lowest energy from your calculation, as well as some usefull
functions to get intermediate values such as MO coefficients, density and fock matrices.
\index{UHF (class in ghf.UHF)@\spxentry{UHF}\spxextra{class in ghf.UHF}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{UHF:ghf.UHF.UHF}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{ghf.UHF.}}\sphinxbfcode{\sphinxupquote{UHF}}}{\emph{molecule}, \emph{number\_of\_electrons}}{}
Input is a molecule and the number of electrons.

Molecules are made in pySCF and calculations are performed as follows, eg.:
The following snippet prints and returns UHF energy of h\_3
and the number of iterations needed to get this value.

For a normal scf calculation your input looks like the following example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{h3} \PYG{o}{=} \PYG{n}{gto}\PYG{o}{.}\PYG{n}{M}\PYG{p}{(}\PYG{n}{atom} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{h 0 0 0; h 0 0.86602540378 0.5; h 0 0 1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{spin} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{basis} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cc\PYGZhy{}pvdz}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x} \PYG{o}{=} \PYG{n}{UHF}\PYG{p}{(}\PYG{n}{h3}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x}\PYG{o}{.}\PYG{n}{get\PYGZus{}scf\PYGZus{}solution}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{Number of iterations: 62}
\PYG{g+go}{Converged SCF energy in Hartree: \PYGZhy{}1.5062743202681235 (UHF)}
\PYG{g+go}{\PYGZlt{}S\PYGZca{}2\PYGZgt{} = 0.7735672504295973, \PYGZlt{}S\PYGZus{}z\PYGZgt{} = 0.5, Multiplicity = 2.023430009098014}
\end{sphinxVerbatim}
\index{diis() (ghf.UHF.UHF method)@\spxentry{diis()}\spxextra{ghf.UHF.UHF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{UHF:ghf.UHF.UHF.diis}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{diis}}}{\emph{initial\_guess=None}, \emph{convergence=1e-12}}{}
When needed, DIIS can be used to speed up the UHF calculations by reducing the needed iterations.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{initial\_guess}} \textendash{} Initial guess for the scf procedure. None specified: core Hamiltonian.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{convergence}} \textendash{} Set the convergence criterion. If none is given, 1e-12 is used.

\end{itemize}

\item[{Returns}] \leavevmode
scf energy, number of iterations, mo coefficients, last density matrix, last fock matrix

\end{description}\end{quote}

\end{fulllineitems}

\index{extra\_electron\_guess() (ghf.UHF.UHF method)@\spxentry{extra\_electron\_guess()}\spxextra{ghf.UHF.UHF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{UHF:ghf.UHF.UHF.extra_electron_guess}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{extra\_electron\_guess}}}{}{}
This method adds two electrons to the system in order to get coefficients that can be used as a better guess
for the scf procedure. This essentially forces the system into it’s \textless{}S\_z\textgreater{} = 0 state.

To perform a calculation with this method, you will have to work as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{h4} \PYG{o}{=} \PYG{n}{gto}\PYG{o}{.}\PYG{n}{M}\PYG{p}{(}\PYG{n}{atom} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{h 0 0 0; h 1 0 0; h 0 1 0; h 1 1 0}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{,} \PYG{n}{spin} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{basis} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cc\PYGZhy{}pvdz}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x} \PYG{o}{=} \PYG{n}{UHF}\PYG{p}{(}\PYG{n}{h4}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{guess} \PYG{o}{=} \PYG{n}{x}\PYG{o}{.}\PYG{n}{extra\PYGZus{}electron\PYGZus{}guess}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x}\PYG{o}{.}\PYG{n}{get\PYGZus{}scf\PYGZus{}solution}\PYG{p}{(}\PYG{n}{guess}\PYG{p}{)}
\PYG{g+go}{Number of iterations: 74}
\PYG{g+go}{Converged SCF energy in Hartree: \PYGZhy{}2.0210882477030547 (UHF)}
\PYG{g+go}{\PYGZlt{}S\PYGZca{}2\PYGZgt{} = 1.0565277001056579, \PYGZlt{}S\PYGZus{}z\PYGZgt{} = 0.0, Multiplicity = 2.2860688529487976}
\end{sphinxVerbatim}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
A new guess matrix to use for the scf procedure.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_last\_dens() (ghf.UHF.UHF method)@\spxentry{get\_last\_dens()}\spxextra{ghf.UHF.UHF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{UHF:ghf.UHF.UHF.get_last_dens}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_last\_dens}}}{}{}
Gets the last density matrix of the converged solution.
Alpha density in the first matrix, beta density in the second.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The last density matrix.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_last\_fock() (ghf.UHF.UHF method)@\spxentry{get\_last\_fock()}\spxextra{ghf.UHF.UHF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{UHF:ghf.UHF.UHF.get_last_fock}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_last\_fock}}}{}{}
Gets the last fock matrix of the converged solution.
Alpha Fock matrix first, beta Fock matrix second.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The last Fock matrix.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_mo\_coeff() (ghf.UHF.UHF method)@\spxentry{get\_mo\_coeff()}\spxextra{ghf.UHF.UHF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{UHF:ghf.UHF.UHF.get_mo_coeff}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_mo\_coeff}}}{}{}
Gets the mo coefficients of the converged solution.
Alpha coefficients in the first matrix, beta coefficients in the second.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The mo coefficients

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_one\_e() (ghf.UHF.UHF method)@\spxentry{get\_one\_e()}\spxextra{ghf.UHF.UHF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{UHF:ghf.UHF.UHF.get_one_e}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_one\_e}}}{}{}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The one electron integral matrix: T + V

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_ovlp() (ghf.UHF.UHF method)@\spxentry{get\_ovlp()}\spxextra{ghf.UHF.UHF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{UHF:ghf.UHF.UHF.get_ovlp}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_ovlp}}}{}{}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The overlap matrix

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_scf\_solution() (ghf.UHF.UHF method)@\spxentry{get\_scf\_solution()}\spxextra{ghf.UHF.UHF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{UHF:ghf.UHF.UHF.get_scf_solution}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_scf\_solution}}}{\emph{guess=None}, \emph{convergence=1e-12}}{}
Prints the number of iterations and the converged scf energy.
Also prints the expectation value of S\_z, S\textasciicircum{}2 and the multiplicity.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{guess}} \textendash{} The initial guess for the scf procedure. If none is given: core Hamiltonian.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{convergence}} \textendash{} Set the convergence criterion. If none is given, 1e-12 is used.

\end{itemize}

\item[{Returns}] \leavevmode
The converged scf energy.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_scf\_solution\_diis() (ghf.UHF.UHF method)@\spxentry{get\_scf\_solution\_diis()}\spxextra{ghf.UHF.UHF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{UHF:ghf.UHF.UHF.get_scf_solution_diis}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_scf\_solution\_diis}}}{\emph{guess=None}, \emph{convergence=1e-12}}{}
Prints the number of iterations and the converged diis energy.
Also prints the expectation value of S\_z, S\textasciicircum{}2 and the multiplicity.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{guess}} \textendash{} The initial guess. If none is specified, core Hamiltonian.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{convergence}} \textendash{} Set the convergence criterion. If none is given, 1e-12 is used.

\end{itemize}

\item[{Returns}] \leavevmode
The converged diis energy.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_two\_e() (ghf.UHF.UHF method)@\spxentry{get\_two\_e()}\spxextra{ghf.UHF.UHF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{UHF:ghf.UHF.UHF.get_two_e}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_two\_e}}}{}{}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The electron repulsion interaction tensor

\end{description}\end{quote}

\end{fulllineitems}

\index{nuc\_rep() (ghf.UHF.UHF method)@\spxentry{nuc\_rep()}\spxextra{ghf.UHF.UHF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{UHF:ghf.UHF.UHF.nuc_rep}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{nuc\_rep}}}{}{}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The nuclear repulsion value

\end{description}\end{quote}

\end{fulllineitems}

\index{scf() (ghf.UHF.UHF method)@\spxentry{scf()}\spxextra{ghf.UHF.UHF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{UHF:ghf.UHF.UHF.scf}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{scf}}}{\emph{initial\_guess=None}, \emph{convergence=1e-12}}{}
Performs a self consistent field calculation to find the lowest UHF energy.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{initial\_guess}} \textendash{} A tuple of an alpha and beta guess matrix. If none, the core hamiltonian will be used.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{convergence}} \textendash{} Set the convergence criterion. If none is given, 1e-12 is used.

\end{itemize}

\item[{Returns}] \leavevmode
The scf energy, number of iterations, the mo coefficients, the last density and the last fock matrices

\end{description}\end{quote}

\end{fulllineitems}

\index{stability() (ghf.UHF.UHF method)@\spxentry{stability()}\spxextra{ghf.UHF.UHF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{UHF:ghf.UHF.UHF.stability}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{stability}}}{}{}
Performing a stability analysis checks whether or not the wave function is stable, by checking the lowest eigen-
value of the Hessian matrix. If there’s an instability, the MO’s will be rotated in the direction
of the lowest eigenvalue. These new MO’s can then be used to start a new scf procedure.

To perform a stability analysis, use the following syntax:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{h4} \PYG{o}{=} \PYG{n}{gto}\PYG{o}{.}\PYG{n}{M}\PYG{p}{(}\PYG{n}{atom} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{h 0 0 0; h 1 0 0; h 0 1 0; h 1 1 0}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{,} \PYG{n}{spin} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{basis} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cc\PYGZhy{}pvdz}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x} \PYG{o}{=} \PYG{n}{UHF}\PYG{p}{(}\PYG{n}{h4}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{guess} \PYG{o}{=} \PYG{n}{x}\PYG{o}{.}\PYG{n}{stability}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x}\PYG{o}{.}\PYG{n}{get\PYGZus{}scf\PYGZus{}solution}\PYG{p}{(}\PYG{n}{guess}\PYG{p}{)}
\PYG{g+go}{There is an internal instability in the UHF wave function.}
\PYG{g+go}{Number of iterations: 78}
\PYG{g+go}{Converged SCF energy in Hartree: \PYGZhy{}2.0210882477030716 (UHF)}
\PYG{g+go}{\PYGZlt{}S\PYGZca{}2\PYGZgt{} = 1.056527700105677, \PYGZlt{}S\PYGZus{}z\PYGZgt{} = 0.0, Multiplicity = 2.2860688529488145}
\end{sphinxVerbatim}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
New and improved MO’s.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\phantomsection\label{\detokenize{Real_GHF:module-ghf.real_GHF}}\index{ghf.real\_GHF (module)@\spxentry{ghf.real\_GHF}\spxextra{module}}

\chapter{Real generalised Hartree Fock, by means of SCF procedure}
\label{\detokenize{Real_GHF:real-generalised-hartree-fock-by-means-of-scf-procedure}}\label{\detokenize{Real_GHF::doc}}
This class creates a generalised Hartree-Fock object which can be used for scf calculations. Different initial guesses
are provided as well as the option to perform a stability analysis.
The molecule has to be created in pySCF:
molecule = gto.M(atom = geometry, spin = diff. in alpha and beta electrons, basis = basis set)
\index{RealGHF (class in ghf.real\_GHF)@\spxentry{RealGHF}\spxextra{class in ghf.real\_GHF}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Real_GHF:ghf.real_GHF.RealGHF}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{ghf.real\_GHF.}}\sphinxbfcode{\sphinxupquote{RealGHF}}}{\emph{molecule}, \emph{number\_of\_electrons}}{}
Input is a molecule and the number of electrons.

Molecules are made in pySCF and calculations are performed as follows, eg.:
The following snippet prints and returns UHF energy of h3
and the number of iterations needed to get this value.

For a normal scf calculation your input looks like the following example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{h3} \PYG{o}{=} \PYG{n}{gto}\PYG{o}{.}\PYG{n}{M}\PYG{p}{(}\PYG{n}{atom} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{h 0 0 0; h 0 0.86602540378 0.5; h 0 0 1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{spin} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{basis} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cc\PYGZhy{}pvdz}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x} \PYG{o}{=} \PYG{n}{RealGHF}\PYG{p}{(}\PYG{n}{h3}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x}\PYG{o}{.} \PYG{n}{get\PYGZus{}scf\PYGZus{}solution}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{Number of iterations: 82}
\PYG{g+go}{Converged SCF energy in Hartree: \PYGZhy{}1.5062743202607725 (Real GHF)}
\end{sphinxVerbatim}
\index{diis() (ghf.real\_GHF.RealGHF method)@\spxentry{diis()}\spxextra{ghf.real\_GHF.RealGHF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Real_GHF:ghf.real_GHF.RealGHF.diis}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{diis}}}{\emph{guess=None}, \emph{convergence=1e-12}}{}
The DIIS method is an alternative to the standard scf procedure. It reduces the number of iterations needed to
find a solution. The same guesses can be used as for a standard scf calculation. Stability analysis can be
done as well.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{convergence}} \textendash{} Set the convergence criterion. If none is given, 1e-12 is used.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{guess}} \textendash{} The initial guess matrix, if none is specified, the spin blocked core Hamiltonian is used.

\end{itemize}

\item[{Returns}] \leavevmode
scf\_energy, iterations, mo coefficients, last density matrix \& last Fock matrix

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_last\_dens() (ghf.real\_GHF.RealGHF method)@\spxentry{get\_last\_dens()}\spxextra{ghf.real\_GHF.RealGHF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Real_GHF:ghf.real_GHF.RealGHF.get_last_dens}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_last\_dens}}}{}{}
Gets the last density matrix of the converged solution.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The last density matrix.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_last\_fock() (ghf.real\_GHF.RealGHF method)@\spxentry{get\_last\_fock()}\spxextra{ghf.real\_GHF.RealGHF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Real_GHF:ghf.real_GHF.RealGHF.get_last_fock}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_last\_fock}}}{}{}
Gets the last fock matrix of the converged solution.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The last Fock matrix.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_mo\_coeff() (ghf.real\_GHF.RealGHF method)@\spxentry{get\_mo\_coeff()}\spxextra{ghf.real\_GHF.RealGHF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Real_GHF:ghf.real_GHF.RealGHF.get_mo_coeff}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_mo\_coeff}}}{}{}
Gets the mo coefficients of the converged solution.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The mo coefficients

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_one\_e() (ghf.real\_GHF.RealGHF method)@\spxentry{get\_one\_e()}\spxextra{ghf.real\_GHF.RealGHF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Real_GHF:ghf.real_GHF.RealGHF.get_one_e}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_one\_e}}}{}{}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The one electron integral matrix: T + V

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_ovlp() (ghf.real\_GHF.RealGHF method)@\spxentry{get\_ovlp()}\spxextra{ghf.real\_GHF.RealGHF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Real_GHF:ghf.real_GHF.RealGHF.get_ovlp}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_ovlp}}}{}{}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The overlap matrix

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_scf\_solution() (ghf.real\_GHF.RealGHF method)@\spxentry{get\_scf\_solution()}\spxextra{ghf.real\_GHF.RealGHF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Real_GHF:ghf.real_GHF.RealGHF.get_scf_solution}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_scf\_solution}}}{\emph{guess=None}, \emph{convergence=1e-12}}{}
Prints the number of iterations and the converged scf energy.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{guess}} \textendash{} Initial guess for scf. If none is specified: expanded core Hamiltonian.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{convergence}} \textendash{} Set the convergence criterion. If none is given, 1e-12 is used.

\end{itemize}

\item[{Returns}] \leavevmode
The converged scf energy.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_scf\_solution\_diis() (ghf.real\_GHF.RealGHF method)@\spxentry{get\_scf\_solution\_diis()}\spxextra{ghf.real\_GHF.RealGHF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Real_GHF:ghf.real_GHF.RealGHF.get_scf_solution_diis}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_scf\_solution\_diis}}}{\emph{guess=None}, \emph{convergence=1e-12}}{}
Prints the number of iterations and the converged energy after a diis calculation. Guesses can also be specified
just like with a normal scf calculation.

Example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{h3} \PYG{o}{=} \PYG{n}{gto}\PYG{o}{.}\PYG{n}{M}\PYG{p}{(}\PYG{n}{atom} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{h 0 0 0; h 0 0.86602540378 0.5; h 0 0 1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{spin} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{basis} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cc\PYGZhy{}pvdz}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x} \PYG{o}{=} \PYG{n}{RealGHF}\PYG{p}{(}\PYG{n}{h3}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{guess} \PYG{o}{=} \PYG{n}{x}\PYG{o}{.}\PYG{n}{random\PYGZus{}guess}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x}\PYG{o}{.}\PYG{n}{get\PYGZus{}scf\PYGZus{}solution\PYGZus{}diis}\PYG{p}{(}\PYG{n}{guess}\PYG{p}{)}
\PYG{g+go}{Number of iterations: 37}
\PYG{g+go}{Converged SCF energy in Hartree: \PYGZhy{}1.5062743202915496 (Real GHF)}
\end{sphinxVerbatim}

Without DIIS, 82 iterations are needed to find this solution.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{guess}} \textendash{} Initial guess for scf. None specified: expanded core Hamiltonian

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{convergence}} \textendash{} Set the convergence criterion. If none is given, 1e-12 is used.

\end{itemize}

\item[{Returns}] \leavevmode
The converged scf energy.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_two\_e() (ghf.real\_GHF.RealGHF method)@\spxentry{get\_two\_e()}\spxextra{ghf.real\_GHF.RealGHF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Real_GHF:ghf.real_GHF.RealGHF.get_two_e}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_two\_e}}}{}{}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The electron repulsion interaction tensor

\end{description}\end{quote}

\end{fulllineitems}

\index{nuc\_rep() (ghf.real\_GHF.RealGHF method)@\spxentry{nuc\_rep()}\spxextra{ghf.real\_GHF.RealGHF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Real_GHF:ghf.real_GHF.RealGHF.nuc_rep}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{nuc\_rep}}}{}{}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The nuclear repulsion value

\end{description}\end{quote}

\end{fulllineitems}

\index{random\_guess() (ghf.real\_GHF.RealGHF method)@\spxentry{random\_guess()}\spxextra{ghf.real\_GHF.RealGHF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Real_GHF:ghf.real_GHF.RealGHF.random_guess}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{random\_guess}}}{}{}
A function that creates a matrix with random values that can be used as an initial guess
for the SCF calculations.

To use this guess:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{h3} \PYG{o}{=} \PYG{n}{gto}\PYG{o}{.}\PYG{n}{M}\PYG{p}{(}\PYG{n}{atom} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{h 0 0 0; h 0 0.86602540378 0.5; h 0 0 1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{spin} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{basis} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cc\PYGZhy{}pvdz}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x} \PYG{o}{=} \PYG{n}{RealGHF}\PYG{p}{(}\PYG{n}{h3}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{guess} \PYG{o}{=} \PYG{n}{x}\PYG{o}{.}\PYG{n}{random\PYGZus{}guess}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x}\PYG{o}{.}\PYG{n}{get\PYGZus{}scf\PYGZus{}solution}\PYG{p}{(}\PYG{n}{guess}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
A random hermitian matrix.

\end{description}\end{quote}

\end{fulllineitems}

\index{scf() (ghf.real\_GHF.RealGHF method)@\spxentry{scf()}\spxextra{ghf.real\_GHF.RealGHF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Real_GHF:ghf.real_GHF.RealGHF.scf}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{scf}}}{\emph{guess=None}, \emph{convergence=1e-12}}{}
This function performs the SCF calculation by using the generalised Hartree-Fock formulas. Since we’re working
in the real class, all values throughout are real. For complex, see the “complex\_GHF” class.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{guess}} \textendash{} Initial guess to start SCF. If none is given, core hamiltonian will be used.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{convergence}} \textendash{} Set the convergence criterion. If none is given, 1e-12 is used.

\end{itemize}

\item[{Returns}] \leavevmode
scf\_energy, iterations, mo coefficients, last density matrix \& last Fock matrix

\end{description}\end{quote}

\end{fulllineitems}

\index{stability() (ghf.real\_GHF.RealGHF method)@\spxentry{stability()}\spxextra{ghf.real\_GHF.RealGHF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Real_GHF:ghf.real_GHF.RealGHF.stability}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{stability}}}{}{}
Performing a stability analysis checks whether or not the wave function is stable, by checking the lowest
eigenvalue of the Hessian matrix. If there’s an instability, the MO’s will be rotated in the direction
of the lowest eigenvalue. These new MO’s can then be used to start a new scf procedure.

To perform a stability analysis, use the following syntax, this will continue the analysis until there is
no more instability:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{h4} \PYG{o}{=} \PYG{n}{gto}\PYG{o}{.}\PYG{n}{M}\PYG{p}{(}\PYG{n}{atom} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{h 0 0 0; h 1 0 0; h 0 1 0; h 1 1 0}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{,} \PYG{n}{spin} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{basis} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cc\PYGZhy{}pvdz}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x} \PYG{o}{=} \PYG{n}{RealGHF}\PYG{p}{(}\PYG{n}{h4}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x}\PYG{o}{.}\PYG{n}{scf}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{guess} \PYG{o}{=} \PYG{n}{x}\PYG{o}{.}\PYG{n}{stability}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{while} \PYG{n}{x}\PYG{o}{.}\PYG{n}{instability}\PYG{p}{:}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }    \PYG{n}{new\PYGZus{}guess} \PYG{o}{=} \PYG{n}{x}\PYG{o}{.}\PYG{n}{stability}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }    \PYG{n}{x}\PYG{o}{.}\PYG{n}{get\PYGZus{}scf\PYGZus{}solution}\PYG{p}{(}\PYG{n}{new\PYGZus{}guess}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
New and improved MO’s.

\end{description}\end{quote}

\end{fulllineitems}

\index{unitary\_rotation\_guess() (ghf.real\_GHF.RealGHF method)@\spxentry{unitary\_rotation\_guess()}\spxextra{ghf.real\_GHF.RealGHF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Real_GHF:ghf.real_GHF.RealGHF.unitary_rotation_guess}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{unitary\_rotation\_guess}}}{}{}
A function that creates an initial guess matrix by performing a unitary transformation on the core Hamiltonian
matrix.

To use this guess:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{h3} \PYG{o}{=} \PYG{n}{gto}\PYG{o}{.}\PYG{n}{M}\PYG{p}{(}\PYG{n}{atom} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{h 0 0 0; h 0 0.86602540378 0.5; h 0 0 1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{spin} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{basis} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cc\PYGZhy{}pvdz}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x} \PYG{o}{=} \PYG{n}{RealGHF}\PYG{p}{(}\PYG{n}{h3}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{guess} \PYG{o}{=} \PYG{n}{x}\PYG{o}{.}\PYG{n}{unitary\PYGZus{}rotation\PYGZus{}guess}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x}\PYG{o}{.}\PYG{n}{get\PYGZus{}scf\PYGZus{}solution}\PYG{p}{(}\PYG{n}{guess}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
A rotated guess matrix.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\phantomsection\label{\detokenize{Complex_GHF:module-ghf.complex_GHF}}\index{ghf.complex\_GHF (module)@\spxentry{ghf.complex\_GHF}\spxextra{module}}

\chapter{Complex generalised Hartree Fock, by means of SCF procedure}
\label{\detokenize{Complex_GHF:complex-generalised-hartree-fock-by-means-of-scf-procedure}}\label{\detokenize{Complex_GHF::doc}}
This class creates a generalised Hartree-Fock object which can be used for scf calculations. Different initial guesses
are provided as well as the option to perform a stability analysis.
The molecule has to be created in pySCF:
molecule = gto.M(atom = geometry, spin = diff. in alpha and beta electrons, basis = basis set)
\index{ComplexGHF (class in ghf.complex\_GHF)@\spxentry{ComplexGHF}\spxextra{class in ghf.complex\_GHF}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Complex_GHF:ghf.complex_GHF.ComplexGHF}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{ghf.complex\_GHF.}}\sphinxbfcode{\sphinxupquote{ComplexGHF}}}{\emph{molecule}, \emph{number\_of\_electrons}}{}
Input is a molecule and the number of electrons.

Molecules are made in pySCF and calculations are performed as follows, eg.:
The following snippet prints and returns UHF energy of h3
and the number of iterations needed to get this value.

For a normal scf calculation your input looks like the following example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{h3} \PYG{o}{=} \PYG{n}{gto}\PYG{o}{.}\PYG{n}{M}\PYG{p}{(}\PYG{n}{atom} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{h 0 0 0; h 0 0.86602540378 0.5; h 0 0 1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{spin} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{basis} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cc\PYGZhy{}pvdz}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x} \PYG{o}{=} \PYG{n}{ComplexGHF}\PYG{p}{(}\PYG{n}{h3}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x}\PYG{o}{.}\PYG{n}{loop\PYGZus{}calculations}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}
\index{diis() (ghf.complex\_GHF.ComplexGHF method)@\spxentry{diis()}\spxextra{ghf.complex\_GHF.ComplexGHF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Complex_GHF:ghf.complex_GHF.ComplexGHF.diis}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{diis}}}{\emph{guess=None}, \emph{convergence=1e-12}}{}
The DIIS method is an alternative to the standard scf procedure. It reduces the number of iterations needed to
find a solution. The same guesses can be used as for a standard scf calculation. Stability analysis can be
done as well.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{guess}} \textendash{} The initial guess matrix, if none is specified: expanded core Hamiltonian unitarily rotated.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{convergence}} \textendash{} Set the convergence criterion. If none is given, 1e-12 is used.

\end{itemize}

\item[{Returns}] \leavevmode
scf\_energy, iterations, mo coefficients, last density matrix \& last Fock matrix

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_last\_dens() (ghf.complex\_GHF.ComplexGHF method)@\spxentry{get\_last\_dens()}\spxextra{ghf.complex\_GHF.ComplexGHF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Complex_GHF:ghf.complex_GHF.ComplexGHF.get_last_dens}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_last\_dens}}}{}{}
Gets the last density matrix of the converged solution.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The last density matrix.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_last\_fock() (ghf.complex\_GHF.ComplexGHF method)@\spxentry{get\_last\_fock()}\spxextra{ghf.complex\_GHF.ComplexGHF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Complex_GHF:ghf.complex_GHF.ComplexGHF.get_last_fock}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_last\_fock}}}{}{}
Gets the last fock matrix of the converged solution.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The last Fock matrix.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_mo\_coeff() (ghf.complex\_GHF.ComplexGHF method)@\spxentry{get\_mo\_coeff()}\spxextra{ghf.complex\_GHF.ComplexGHF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Complex_GHF:ghf.complex_GHF.ComplexGHF.get_mo_coeff}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_mo\_coeff}}}{}{}
Gets the mo coefficients of the converged solution.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The mo coefficients

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_one\_e() (ghf.complex\_GHF.ComplexGHF method)@\spxentry{get\_one\_e()}\spxextra{ghf.complex\_GHF.ComplexGHF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Complex_GHF:ghf.complex_GHF.ComplexGHF.get_one_e}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_one\_e}}}{}{}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The one electron integral matrix: T + V

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_ovlp() (ghf.complex\_GHF.ComplexGHF method)@\spxentry{get\_ovlp()}\spxextra{ghf.complex\_GHF.ComplexGHF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Complex_GHF:ghf.complex_GHF.ComplexGHF.get_ovlp}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_ovlp}}}{}{}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The overlap matrix

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_scf\_solution() (ghf.complex\_GHF.ComplexGHF method)@\spxentry{get\_scf\_solution()}\spxextra{ghf.complex\_GHF.ComplexGHF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Complex_GHF:ghf.complex_GHF.ComplexGHF.get_scf_solution}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_scf\_solution}}}{\emph{guess=None}, \emph{convergence=1e-12}}{}
Prints the number of iterations and the converged scf energy.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{guess}} \textendash{} The initial scf guess. None specified: core Hamiltonian unitarily rotated with complex U matrix.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{convergence}} \textendash{} Set the convergence criterion. If none is given, 1e-12 is used.

\end{itemize}

\item[{Returns}] \leavevmode
The converged scf energy.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_scf\_solution\_diis() (ghf.complex\_GHF.ComplexGHF method)@\spxentry{get\_scf\_solution\_diis()}\spxextra{ghf.complex\_GHF.ComplexGHF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Complex_GHF:ghf.complex_GHF.ComplexGHF.get_scf_solution_diis}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_scf\_solution\_diis}}}{\emph{guess=None}, \emph{convergence=1e-12}}{}
Prints the number of iterations and the converged energy after a diis calculation. Guesses can also be specified
just like with a normal scf calculation.

Example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{h3} \PYG{o}{=} \PYG{n}{gto}\PYG{o}{.}\PYG{n}{M}\PYG{p}{(}\PYG{n}{atom} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{h 0 0 0; h 0 0.86602540378 0.5; h 0 0 1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{spin} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{basis} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cc\PYGZhy{}pvdz}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x} \PYG{o}{=} \PYG{n}{ComplexGHF}\PYG{p}{(}\PYG{n}{h3}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{guess} \PYG{o}{=} \PYG{n}{x}\PYG{o}{.}\PYG{n}{random\PYGZus{}guess}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x}\PYG{o}{.}\PYG{n}{get\PYGZus{}scf\PYGZus{}solution\PYGZus{}diis}\PYG{p}{(}\PYG{n}{guess}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{guess}} \textendash{} Initial scf guess. None specified: core HAmiltonian unitarily rotated with complex U matrix.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{convergence}} \textendash{} Set the convergence criterion. If none is given, 1e-12 is used.

\end{itemize}

\item[{Returns}] \leavevmode
The converged scf energy.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_two\_e() (ghf.complex\_GHF.ComplexGHF method)@\spxentry{get\_two\_e()}\spxextra{ghf.complex\_GHF.ComplexGHF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Complex_GHF:ghf.complex_GHF.ComplexGHF.get_two_e}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_two\_e}}}{}{}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The electron repulsion interaction tensor

\end{description}\end{quote}

\end{fulllineitems}

\index{loop\_calculations() (ghf.complex\_GHF.ComplexGHF method)@\spxentry{loop\_calculations()}\spxextra{ghf.complex\_GHF.ComplexGHF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Complex_GHF:ghf.complex_GHF.ComplexGHF.loop_calculations}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{loop\_calculations}}}{\emph{number\_of\_loops}, \emph{guess=None}, \emph{convergence=1e-12}}{}
This function is specifically catered to the random guess method. Since it is hard to predict the seed of the
correct random matrix, a simple solution is to repeat the scf calculation a certain number of times, starting
from different random guesses and returning the lowest value of all the different calculations. The loops will
automatically perform a stability analysis until there is no more instability in the wave function.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{number\_of\_loops}} \textendash{} The amount of times you want to repeat the scf + stability procedure.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{guess}} \textendash{} The guess used for the scf procedure.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{convergence}} \textendash{} Set the convergence criterion. If none is given, 1e-12 is used.

\end{itemize}

\item[{Returns}] \leavevmode
The scf energy after the loops.

\end{description}\end{quote}

\end{fulllineitems}

\index{loop\_calculations\_diis() (ghf.complex\_GHF.ComplexGHF method)@\spxentry{loop\_calculations\_diis()}\spxextra{ghf.complex\_GHF.ComplexGHF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Complex_GHF:ghf.complex_GHF.ComplexGHF.loop_calculations_diis}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{loop\_calculations\_diis}}}{\emph{number\_of\_loops}, \emph{guess=None}, \emph{convergence=1e-12}}{}
This function is specifically catered to the random guess method. Since it is hard to predict the seed of the
correct random matrix, a simple solution is to repeat the scf calculation a certain number of times, starting
from different random guesses and returning the lowest value of all the different calculations. The loops will
automatically perform a stability analysis until there is no more instability in the wave function. This option
uses the DIIS iteration so that convergence is generally reached faster.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{number\_of\_loops}} \textendash{} The amount of times you want to repeat the DIIS + stability procedure.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{guess}} \textendash{} The guess used for the DIIS procedure.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{convergence}} \textendash{} Set the convergence criterion. If none is given, 1e-12 is used.

\end{itemize}

\item[{Returns}] \leavevmode
The energy after the loops.

\end{description}\end{quote}

\end{fulllineitems}

\index{nuc\_rep() (ghf.complex\_GHF.ComplexGHF method)@\spxentry{nuc\_rep()}\spxextra{ghf.complex\_GHF.ComplexGHF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Complex_GHF:ghf.complex_GHF.ComplexGHF.nuc_rep}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{nuc\_rep}}}{}{}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The nuclear repulsion value

\end{description}\end{quote}

\end{fulllineitems}

\index{random\_guess() (ghf.complex\_GHF.ComplexGHF method)@\spxentry{random\_guess()}\spxextra{ghf.complex\_GHF.ComplexGHF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Complex_GHF:ghf.complex_GHF.ComplexGHF.random_guess}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{random\_guess}}}{}{}
A function that creates a matrix with random values that can be used as an initial guess
for the SCF calculations.

IMPORTANT: It is recommended to use a random guess since the results are significantly better
than those found when using the standard guess.

To use this guess:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{h3} \PYG{o}{=} \PYG{n}{gto}\PYG{o}{.}\PYG{n}{M}\PYG{p}{(}\PYG{n}{atom} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{h 0 0 0; h 0 0.86602540378 0.5; h 0 0 1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{spin} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{basis} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cc\PYGZhy{}pvdz}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x} \PYG{o}{=} \PYG{n}{ComplexGHF}\PYG{p}{(}\PYG{n}{h3}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{guess} \PYG{o}{=} \PYG{n}{x}\PYG{o}{.}\PYG{n}{random\PYGZus{}guess}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x}\PYG{o}{.}\PYG{n}{get\PYGZus{}scf\PYGZus{}solution}\PYG{p}{(}\PYG{n}{guess}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
A random hermitian matrix.

\end{description}\end{quote}

\end{fulllineitems}

\index{scf() (ghf.complex\_GHF.ComplexGHF method)@\spxentry{scf()}\spxextra{ghf.complex\_GHF.ComplexGHF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Complex_GHF:ghf.complex_GHF.ComplexGHF.scf}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{scf}}}{\emph{guess=None}, \emph{convergence=1e-12}}{}
This function performs the SCF calculation by using the generalised Hartree-Fock formulas. Since we’re working
in the complex GHF class, all values throughout are complex.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{convergence}} \textendash{} Set the convergence criterion. If none is given, 1e-12 is used.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{guess}} \textendash{} Initial guess for scf. If none is given, a unitary rotation on the core Hamiltonian is used.

\end{itemize}

\item[{Returns}] \leavevmode
scf\_energy, iterations, mo coefficients, last density matrix \& last Fock matrix

\end{description}\end{quote}

\end{fulllineitems}

\index{stability() (ghf.complex\_GHF.ComplexGHF method)@\spxentry{stability()}\spxextra{ghf.complex\_GHF.ComplexGHF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Complex_GHF:ghf.complex_GHF.ComplexGHF.stability}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{stability}}}{}{}
Performing a stability analysis checks whether or not the wave function is stable, by checking the lowest
eigenvalue of the Hessian matrix. If there’s an instability, the MO’s will be rotated in the direction
of the lowest eigenvalue. These new MO’s can then be used to start a new scf procedure.

To perform a stability analysis, use the following syntax, this will continue the analysis until there is
no more instability:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{h4} \PYG{o}{=} \PYG{n}{gto}\PYG{o}{.}\PYG{n}{M}\PYG{p}{(}\PYG{n}{atom} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{h 0 0 0; h 1 0 0; h 0 1 0; h 1 1 0}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{,} \PYG{n}{spin} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{basis} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cc\PYGZhy{}pvdz}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x} \PYG{o}{=} \PYG{n}{ComplexGHF}\PYG{p}{(}\PYG{n}{h4}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x}\PYG{o}{.}\PYG{n}{scf}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{guess} \PYG{o}{=} \PYG{n}{x}\PYG{o}{.}\PYG{n}{stability}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{while} \PYG{n}{x}\PYG{o}{.}\PYG{n}{instability}\PYG{p}{:}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }    \PYG{n}{new\PYGZus{}guess} \PYG{o}{=} \PYG{n}{x}\PYG{o}{.}\PYG{n}{stability}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }    \PYG{n}{x}\PYG{o}{.}\PYG{n}{get\PYGZus{}scf\PYGZus{}solution}\PYG{p}{(}\PYG{n}{new\PYGZus{}guess}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
New and improved MO’s.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\phantomsection\label{\detokenize{SCF_functions:module-ghf.SCF_functions}}\index{ghf.SCF\_functions (module)@\spxentry{ghf.SCF\_functions}\spxextra{module}}

\chapter{Useful functions for SCF procedure}
\label{\detokenize{SCF_functions:useful-functions-for-scf-procedure}}\label{\detokenize{SCF_functions::doc}}
A number of functions used throughout the UHF and RHF calculations are summarised here.
\index{density\_matrix() (in module ghf.SCF\_functions)@\spxentry{density\_matrix()}\spxextra{in module ghf.SCF\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{SCF_functions:ghf.SCF_functions.density_matrix}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ghf.SCF\_functions.}}\sphinxbfcode{\sphinxupquote{density\_matrix}}}{\emph{f\_matrix}, \emph{occ}, \emph{trans}}{}~\begin{itemize}
\item {} 
density() creates a density matrix from a fock matrix and the number of occupied orbitals.

\item {} 
Input is a fock matrix, the number of occupied orbitals, which can be separate for alpha and beta in case of UHF.
And a transformation matrix X.

\end{itemize}

\end{fulllineitems}

\index{expand\_matrix() (in module ghf.SCF\_functions)@\spxentry{expand\_matrix()}\spxextra{in module ghf.SCF\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{SCF_functions:ghf.SCF_functions.expand_matrix}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ghf.SCF\_functions.}}\sphinxbfcode{\sphinxupquote{expand\_matrix}}}{\emph{matrix}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{matrix}} \textendash{} 

\item[{Returns}] \leavevmode
a matrix double the size, where blocks of zero’s are added top right and bottom left.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_integrals() (in module ghf.SCF\_functions)@\spxentry{get\_integrals()}\spxextra{in module ghf.SCF\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{SCF_functions:ghf.SCF_functions.get_integrals}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ghf.SCF\_functions.}}\sphinxbfcode{\sphinxupquote{get\_integrals}}}{\emph{molecule}}{}
A function to calculate your integrals \& nuclear repulsion with pyscf.

\end{fulllineitems}

\index{spin() (in module ghf.SCF\_functions)@\spxentry{spin()}\spxextra{in module ghf.SCF\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{SCF_functions:ghf.SCF_functions.spin}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ghf.SCF\_functions.}}\sphinxbfcode{\sphinxupquote{spin}}}{\emph{occ\_a}, \emph{occ\_b}, \emph{coeff\_a}, \emph{coeff\_b}, \emph{overlap}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{occ\_a}} \textendash{} number of occupied alpha orbitals

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{occ\_b}} \textendash{} number of occupied beta orbitals

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{coeff\_a}} \textendash{} MO coefficients of alpha orbitals

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{coeff\_b}} \textendash{} MO coefficients of beta orbitals

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{overlap}} \textendash{} overlap matrix of the molecule

\end{itemize}

\item[{Returns}] \leavevmode
S\textasciicircum{}2, S\_z and spin multiplicity

\end{description}\end{quote}

\end{fulllineitems}

\index{spin\_blocked() (in module ghf.SCF\_functions)@\spxentry{spin\_blocked()}\spxextra{in module ghf.SCF\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{SCF_functions:ghf.SCF_functions.spin_blocked}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ghf.SCF\_functions.}}\sphinxbfcode{\sphinxupquote{spin\_blocked}}}{\emph{block\_1}, \emph{block\_2}, \emph{block\_3}, \emph{block\_4}}{}
When creating the blocks of the density or fock matrix separately, this function is used to add them together,
and create the total density or Fock matrix in spin Blocked notation.
:return: a density matrix in the spin-blocked notation

\end{fulllineitems}

\index{trans\_matrix() (in module ghf.SCF\_functions)@\spxentry{trans\_matrix()}\spxextra{in module ghf.SCF\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{SCF_functions:ghf.SCF_functions.trans_matrix}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ghf.SCF\_functions.}}\sphinxbfcode{\sphinxupquote{trans\_matrix}}}{\emph{overlap}}{}~\begin{itemize}
\item {} 
Define a transformation matrix X, used to orthogonalize different matrices throughout the calculation.

\item {} 
Input should be an overlap matrix.

\end{itemize}

\end{fulllineitems}

\index{uhf\_fock\_matrix() (in module ghf.SCF\_functions)@\spxentry{uhf\_fock\_matrix()}\spxextra{in module ghf.SCF\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{SCF_functions:ghf.SCF_functions.uhf_fock_matrix}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ghf.SCF\_functions.}}\sphinxbfcode{\sphinxupquote{uhf\_fock\_matrix}}}{\emph{density\_matrix\_1}, \emph{density\_matrix\_2}, \emph{one\_electron}, \emph{two\_electron}}{}~\begin{itemize}
\item {} 
calculate a fock matrix from a given alpha and beta density matrix

\item {} 
fock alpha if 1 = alpha and 2 = beta and vice versa

\item {} 
input is the density matrix for alpha and beta, a one electron matrix and a two electron tensor.

\end{itemize}

\end{fulllineitems}

\index{uhf\_scf\_energy() (in module ghf.SCF\_functions)@\spxentry{uhf\_scf\_energy()}\spxextra{in module ghf.SCF\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{SCF_functions:ghf.SCF_functions.uhf_scf_energy}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ghf.SCF\_functions.}}\sphinxbfcode{\sphinxupquote{uhf\_scf\_energy}}}{\emph{density\_matrix\_a}, \emph{density\_matrix\_b}, \emph{fock\_a}, \emph{fock\_b}, \emph{one\_electron}}{}~\begin{itemize}
\item {} 
calculate the scf energy value from a given density matrix and a given fock matrix for both alpha and beta,
so 4 matrices in total.

\item {} 
then calculate the initial electronic energy and put it into an array

\item {} 
input is the density matrices for alpha and beta, the fock matrices for alpha and beta and lastly a one electron
matrix.

\end{itemize}

\end{fulllineitems}

\phantomsection\label{\detokenize{tests:module-ghf.tests.test_auth}}\index{ghf.tests.test\_auth (module)@\spxentry{ghf.tests.test\_auth}\spxextra{module}}

\chapter{Testing the RHF and UHF methods}
\label{\detokenize{tests:testing-the-rhf-and-uhf-methods}}\label{\detokenize{tests::doc}}
Simple tests to check whether or not the functions return the correct value.
\index{test\_RHF() (in module ghf.tests.test\_auth)@\spxentry{test\_RHF()}\spxextra{in module ghf.tests.test\_auth}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tests:ghf.tests.test_auth.test_RHF}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ghf.tests.test\_auth.}}\sphinxbfcode{\sphinxupquote{test\_RHF}}}{}{}
test\_RHF will test whether or not the RHF method returns the wanted result. The accuracy is 10\textasciicircum{}-11.

\end{fulllineitems}

\index{test\_UHF() (in module ghf.tests.test\_auth)@\spxentry{test\_UHF()}\spxextra{in module ghf.tests.test\_auth}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tests:ghf.tests.test_auth.test_UHF}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ghf.tests.test\_auth.}}\sphinxbfcode{\sphinxupquote{test\_UHF}}}{}{}
test\_UHF will test the regular UHF method, by checking whether or not it returns the expected result. The accuracy is 10\textasciicircum{}-6.

\end{fulllineitems}

\index{test\_extra\_e() (in module ghf.tests.test\_auth)@\spxentry{test\_extra\_e()}\spxextra{in module ghf.tests.test\_auth}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tests:ghf.tests.test_auth.test_extra_e}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ghf.tests.test\_auth.}}\sphinxbfcode{\sphinxupquote{test\_extra\_e}}}{}{}
test\_extra\_e will test the UHF method, with the added option of first adding 2 electrons to the system and using those coefficients
for the actual system, by checking whether or not it returns the expected result. The accuracy is 10\textasciicircum{}-6.

\end{fulllineitems}

\index{test\_stability() (in module ghf.tests.test\_auth)@\spxentry{test\_stability()}\spxextra{in module ghf.tests.test\_auth}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tests:ghf.tests.test_auth.test_stability}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ghf.tests.test\_auth.}}\sphinxbfcode{\sphinxupquote{test\_stability}}}{}{}
test\_stability will test the UHF method, with stability analysis, by checking whether or not it returns the expected result. The accuracy is 10\textasciicircum{}-6.

\end{fulllineitems}



\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\let\bigletter\sphinxstyleindexlettergroup
\bigletter{g}
\item\relax\sphinxstyleindexentry{ghf.complex\_GHF}\sphinxstyleindexpageref{Complex_GHF:\detokenize{module-ghf.complex_GHF}}
\item\relax\sphinxstyleindexentry{ghf.real\_GHF}\sphinxstyleindexpageref{Real_GHF:\detokenize{module-ghf.real_GHF}}
\item\relax\sphinxstyleindexentry{ghf.RHF}\sphinxstyleindexpageref{RHF:\detokenize{module-ghf.RHF}}
\item\relax\sphinxstyleindexentry{ghf.SCF\_functions}\sphinxstyleindexpageref{SCF_functions:\detokenize{module-ghf.SCF_functions}}
\item\relax\sphinxstyleindexentry{ghf.tests.test\_auth}\sphinxstyleindexpageref{tests:\detokenize{module-ghf.tests.test_auth}}
\item\relax\sphinxstyleindexentry{ghf.UHF}\sphinxstyleindexpageref{UHF:\detokenize{module-ghf.UHF}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}